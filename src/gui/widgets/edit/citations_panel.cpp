/*  $Id: citations_panel.cpp 38073 2017-03-23 16:34:10Z filippov $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data,  the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties,  express or implied,  including
 *  warranties of performance,  merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors:  Colleen Bollin
 */


// Generated by DialogBlocks (unregistered), 29/12/2011 15:47:45

#include <ncbi_pch.hpp>
#include <objects/seq/Pubdesc.hpp>
#include <objects/pub/Pub_set.hpp>
#include <objects/pub/Pub_equiv.hpp>
#include <objects/biblio/Cit_gen.hpp>
#include <objects/biblio/PubMedId.hpp>
#include <objects/biblio/MedlineUID.hpp>
#include <objmgr/seqdesc_ci.hpp>
#include <objmgr/feat_ci.hpp>
#include <gui/widgets/wx/wx_utils.hpp>
#include <gui/widgets/edit/utilities.hpp>
#include <gui/objutils/utils.hpp>

////@begin includes
////@end includes

#include "citations_panel.hpp"

////@begin XPM images
////@end XPM images

BEGIN_NCBI_SCOPE
USING_SCOPE(objects);

/*!
 * CCitationsPanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CCitationsPanel, wxPanel )


/*!
 * CCitationsPanel event table definition
 */

BEGIN_EVENT_TABLE( CCitationsPanel, wxPanel )

////@begin CCitationsPanel event table entries
////@end CCitationsPanel event table entries

END_EVENT_TABLE()


/*!
 * CCitationsPanel constructors
 */

CCitationsPanel::CCitationsPanel()
{
    Init();
}

CCitationsPanel::CCitationsPanel( wxWindow* parent, CSeq_feat& seq_feat, CScope& scope,
                                  wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
                                  : m_EditedFeat(new CSeq_feat()), m_Scope(&scope)
{
    Init();
    m_EditedFeat->Assign(seq_feat);
    
    Create(parent, id, pos, size, style);
}


/*!
 * CCitationsPanel creator
 */

bool CCitationsPanel::Create( wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CCitationsPanel creation
    wxPanel::Create( parent, id, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CCitationsPanel creation
    return true;
}


/*!
 * CCitationsPanel destructor
 */

CCitationsPanel::~CCitationsPanel()
{
////@begin CCitationsPanel destruction
////@end CCitationsPanel destruction
}


/*!
 * Member initialisation
 */

void CCitationsPanel::Init()
{
////@begin CCitationsPanel member initialisation
    m_ScrolledWindow = NULL;
    m_Sizer = NULL;
////@end CCitationsPanel member initialisation
}


/*!
 * Control creation for CCitationsPanel
 */

void CCitationsPanel::CreateControls()
{    
////@begin CCitationsPanel content construction
    // Generated by DialogBlocks, 11/01/2012 09:28:33 (unregistered)

    CCitationsPanel* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemPanel1->SetSizer(itemBoxSizer2);

    m_ScrolledWindow = new wxScrolledWindow( itemPanel1, ID_SCROLLEDWINDOW5, wxDefaultPosition, wxSize(100, 100), wxSUNKEN_BORDER|wxHSCROLL|wxVSCROLL );
    if (CCitationsPanel::ShowToolTips())
        m_ScrolledWindow->SetToolTip(_("The use of citations on features is discouraged.  Use this to indicate citations that apply specifically to this feature."));
    itemBoxSizer2->Add(m_ScrolledWindow, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 0);
    m_ScrolledWindow->SetScrollbars(1, 1, 0, 0);
    m_Sizer = new wxBoxSizer(wxVERTICAL);
    m_ScrolledWindow->SetSizer(m_Sizer);

    m_ScrolledWindow->FitInside();

////@end CCitationsPanel content construction
    // add citations
    m_PubList.clear();

    int total_height = 0;
    int total_width = 0;
    int scroll_rate = 0;

    // first get descriptor pubs
    CBioseq_Handle bsh = GetBioseqForSeqFeat(*m_EditedFeat, *m_Scope);
    if (bsh) {
        CSeqdesc_CI di(bsh, CSeqdesc::e_Pub);
        while (di) {
            vector<int> pmids;
            vector<int> muids;
            vector<int> serials;
            vector<string> published_labels;
            vector<string> unpublished_labels;
            GetPubdescLabels(di->GetPub(), pmids, muids, serials, published_labels, unpublished_labels);
            bool can_cit = true;
            if (pmids.size() > 0) {
                CRef<CPub> pub(new CPub());
                pub->SetPmid().Set(pmids[0]);
                m_PubList.push_back(pub);
            } else if (muids.size() > 0) {
                CRef<CPub> pub(new CPub());
                pub->SetMuid(muids[0]);
                m_PubList.push_back(pub);
            } else if (serials.size() > 0) {
                CRef<CPub> pub(new CPub());
                pub->SetGen().SetSerial_number(serials[0]);
                m_PubList.push_back(pub);
            } else if (published_labels.size() > 0) {
                CRef<CPub> pub(new CPub());
                pub->SetGen().SetCit(published_labels[0]);
                m_PubList.push_back(pub);
            } else if (unpublished_labels.size() > 0) {
                CRef<CPub> pub(new CPub());
                pub->SetGen().SetCit(unpublished_labels[0]);
                m_PubList.push_back(pub);
            } else {
                can_cit = false;
            }

            if (can_cit) {
                string label = "";
                di->GetLabel(&label, CSeqdesc::eContent);
                if (NStr::IsBlank(label)) {
                    m_PubList.back()->GetLabel(&label, CPub::eContent, true);
                }
                wxCheckBox* checkbox = new wxCheckBox(m_ScrolledWindow, wxID_ANY, ToWxString(label));
                m_Sizer->Add(checkbox);
                m_Checkboxes.push_back(checkbox);
                int win_height, win_width;
                checkbox->GetSize(&win_width, &win_height);
                total_height += win_height;
                scroll_rate = win_height;
                if (total_width < win_width) {
                    total_width = win_width;
                }
            }
            ++di;
        }
        // now get pub features
        CFeat_CI fi(bsh, SAnnotSelector(CSeqFeatData::e_Pub));
        while (fi) {
            vector<int> pmids;
            vector<int> muids;
            vector<int> serials;
            vector<string> published_labels;
            vector<string> unpublished_labels;
            GetPubdescLabels(fi->GetData().GetPub(), pmids, muids, serials, published_labels, unpublished_labels);
            bool can_cit = true;
            if (pmids.size() > 0) {
                CRef<CPub> pub(new CPub());
                pub->SetPmid().Set(pmids[0]);
                m_PubList.push_back(pub);
            } else if (muids.size() > 0) {
                CRef<CPub> pub(new CPub());
                pub->SetMuid(muids[0]);
                m_PubList.push_back(pub);
            } else if (serials.size() > 0) {
                CRef<CPub> pub(new CPub());
                pub->SetGen().SetSerial_number(serials[0]);
                m_PubList.push_back(pub);
            } else if (published_labels.size() > 0) {
                CRef<CPub> pub(new CPub());
                pub->SetGen().SetCit(published_labels[0]);
                m_PubList.push_back(pub);
            } else if (unpublished_labels.size() > 0) {
                CRef<CPub> pub(new CPub());
                pub->SetGen().SetCit(unpublished_labels[0]);
                m_PubList.push_back(pub);
            } else {
                can_cit = false;
            }

            if (can_cit) {
                string label = "";
                fi->GetData().GetPub().GetPub().GetLabel(&label);
                if (NStr::IsBlank(label)) {
                    m_PubList.back()->GetLabel(&label, CPub::eContent, true);
                }
                wxCheckBox* checkbox = new wxCheckBox(m_ScrolledWindow, wxID_ANY, ToWxString(label));
                m_Sizer->Add(checkbox);
                m_Checkboxes.push_back(checkbox);
                int win_height, win_width;
                checkbox->GetSize(&win_width, &win_height);
                total_height += win_height;
                scroll_rate = win_height;
                if (total_width < win_width) {
                    total_width = win_width;
                }
            }
            ++fi;
        }
    }

    m_ScrolledWindow->SetVirtualSize(total_width, total_height);
    m_ScrolledWindow->SetScrollRate(0, scroll_rate);
    m_ScrolledWindow->FitInside();
    Layout();

//    m_ScrolledWindow->SetSize(total_width + 20, 20 * scroll_rate);
    m_ScrolledWindow->SetMinSize(wxSize(total_width + 20, 20 * scroll_rate));
}


static bool s_DoPubsMatch (const CCit_gen& a, const CCit_gen& b)
{
    if (a.IsSetSerial_number() && b.IsSetSerial_number()
        && a.GetSerial_number() == b.GetSerial_number()) {
        return true;
    } else if (a.IsSetSerial_number() || b.IsSetSerial_number()) {
        return false;
    } else if (a.IsSetCit() && b.IsSetCit()) {
        string x = a.GetCit();
        string y = b.GetCit();
        return (NStr::StartsWith(x, y) || NStr::StartsWith(y, x));
    } else {
        return false;
    }
}


bool s_DoPubsMatch (const CPub& a, const CPub& b)
{
    if (a.IsGen() && b.IsGen()) {
        return s_DoPubsMatch (a.GetGen(), b.GetGen());
    } else if (a.IsPmid() && b.IsPmid()) {
        return (a.GetPmid().Get() == b.GetPmid().Get());
    } else if (a.IsMuid() && b.IsMuid()) {
        return (a.GetMuid() == b.GetMuid());
    } else{
        return false;
    }
}


bool CCitationsPanel::TransferDataToWindow()
{
    if (!wxPanel::TransferDataToWindow())
        return false;

    for (unsigned int i=0; i < m_Checkboxes.size(); i++) {
        m_Checkboxes[i]->SetValue(false);
    }

    if (m_EditedFeat->IsSetCit()) {
        ITERATE( CPub_set::TPub, it, m_EditedFeat->GetCit().GetPub() ) {
            for (unsigned int i = 0; i < m_PubList.size() && i < m_Checkboxes.size(); i++) {
                if (s_DoPubsMatch(**it, *m_PubList[i])) {
                    m_Checkboxes[i]->SetValue(true);
                    break;
                }
            }
        }
    }
                    
    return true;
}


bool CCitationsPanel::TransferDataFromWindow()
{
    if (!wxPanel::TransferDataFromWindow())
        return false;

    m_EditedFeat->ResetCit();
    for (unsigned int i = 0; i < m_PubList.size() && i < m_Checkboxes.size(); i++) {
        if (m_Checkboxes[i]->GetValue()) {
            CRef<CPub> cit(new CPub());
            cit->Assign(*m_PubList[i]);
            m_EditedFeat->SetCit().SetPub().push_back(cit);
        }
    }

    return true;
}


void CCitationsPanel::SetCitations(CSeq_feat& seq_feat)
{
    TransferDataFromWindow();
    seq_feat.ResetCit();
    if (m_EditedFeat->IsSetCit()) {
        ITERATE( CPub_set::TPub, it, m_EditedFeat->GetCit().GetPub() ) {
            CRef<CPub> cit(new CPub());
            cit->Assign(**it);
            seq_feat.SetCit().SetPub().push_back(cit);
        }
    }
}


/*!
 * Should we show tooltips?
 */

bool CCitationsPanel::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap CCitationsPanel::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CCitationsPanel bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CCitationsPanel bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon CCitationsPanel::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CCitationsPanel icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CCitationsPanel icon retrieval
}

END_NCBI_SCOPE
