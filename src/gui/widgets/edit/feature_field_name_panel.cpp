/*  $Id: feature_field_name_panel.cpp 45097 2020-05-29 15:15:00Z asztalos $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data,  the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties,  express or implied,  including
 *  warranties of performance,  merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors:  Colleen Bollin
 */


// Generated by DialogBlocks (unregistered), 10/06/2013 17:47:10

#include <ncbi_pch.hpp>
#include <objects/seqfeat/Genetic_code.hpp>
#include <serial/enumvalues.hpp>
#include <gui/objutils/macro_util.hpp>
#include <gui/objutils/macro_fn_aecr.hpp>
#include <gui/widgets/edit/feature_type_panel.hpp>
#include <gui/widgets/edit/feature_field_name_panel.hpp>

#include <gui/widgets/wx/wx_utils.hpp>
#include <wx/sizer.h>

////@begin XPM images

BEGIN_NCBI_SCOPE
USING_SCOPE(objects);

/*!
 * CFeatureFieldNamePanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CFeatureFieldNamePanel, CFieldNamePanel )

DEFINE_EVENT_TYPE(wxEVT_COMMAND_UPDATE_FEATLIST)

/*!
 * CFeatureFieldNamePanel event table definition
 */

BEGIN_EVENT_TABLE( CFeatureFieldNamePanel, CFieldNamePanel )

////@begin CFeatureFieldNamePanel event table entries
    EVT_LISTBOX( ID_FEATQUALIFIER_LISTBOX, CFeatureFieldNamePanel::OnQualifierListboxSelected)

////@end CFeatureFieldNamePanel event table entries

END_EVENT_TABLE()


/*!
 * CFeatureFieldNamePanel constructors
 */

CFeatureFieldNamePanel::CFeatureFieldNamePanel() 
: m_code_table(CGen_code_table::GetCodeTable())
{
    Init();
}

CFeatureFieldNamePanel::CFeatureFieldNamePanel( wxWindow* parent, CFeatureFieldNamePanel* sibling, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
    : m_Sibling(sibling), m_code_table(CGen_code_table::GetCodeTable())

{
    Init();
    Create(parent, id, pos, size, style);
}


/*!
 * CFeatureFieldNamePanel creator
 */

bool CFeatureFieldNamePanel::Create( wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CFeatureFieldNamePanel creation
    CFieldNamePanel::Create( parent, id, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CFeatureFieldNamePanel creation
    return true;
}


/*!
 * CFeatureFieldNamePanel destructor
 */

CFeatureFieldNamePanel::~CFeatureFieldNamePanel()
{
////@begin CFeatureFieldNamePanel destruction
////@end CFeatureFieldNamePanel destruction
}


/*!
 * Member initialisation
 */

void CFeatureFieldNamePanel::Init()
{
////@begin CFeatureFieldNamePanel member initialisation
    m_FeatureTypeLabel = NULL;
    m_FeatureType = NULL;
    m_QualifierName = NULL;
    m_show_legal_only = false;
////@end CFeatureFieldNamePanel member initialisation
}


/*!
 * Control creation for CFeatureFieldNamePanel
 */

void CFeatureFieldNamePanel::CreateControls()
{    
////@begin CFeatureFieldNamePanel content construction
    CFeatureFieldNamePanel* itemCFieldNamePanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemCFieldNamePanel1->SetSizer(itemBoxSizer2);

    wxFlexGridSizer* itemFlexGridSizer3 = new wxFlexGridSizer(0, 2, 0, 0);
    itemBoxSizer2->Add(itemFlexGridSizer3, 0, wxALIGN_CENTER_HORIZONTAL|wxLEFT|wxRIGHT, 5);

    m_FeatureTypeLabel = new wxStaticText( itemCFieldNamePanel1, wxID_STATIC, _("Feature Type"), wxDefaultPosition, wxDefaultSize, 0 );
    itemFlexGridSizer3->Add(m_FeatureTypeLabel, 0, wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL|wxBOTTOM, 3);

    wxStaticText* itemStaticText5 = new wxStaticText( itemCFieldNamePanel1, wxID_STATIC, _("Qualifier"), wxDefaultPosition, wxDefaultSize, 0 );
    itemFlexGridSizer3->Add(itemStaticText5, 0, wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL|wxBOTTOM, 3);

    m_FeatureType = new CFeatureTypePanel( itemCFieldNamePanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0 );
    itemFlexGridSizer3->Add(m_FeatureType, 0, wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL|wxLEFT|wxRIGHT, 5);

    wxArrayString m_QualifierNameStrings;
    m_QualifierName = new wxListBox(itemCFieldNamePanel1, ID_FEATQUALIFIER_LISTBOX, wxDefaultPosition, wxSize(200, 109), m_QualifierNameStrings, wxLB_SINGLE);
    itemFlexGridSizer3->Add(m_QualifierName, 0, wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL|wxLEFT|wxRIGHT, 5);

////@end CFeatureFieldNamePanel content construction
    if (m_Sibling) {
        m_FeatureTypeLabel->Show(false);
        m_FeatureType->Show(false);
    } 
    
    m_QualifierName->Set(s_FillFeatQualList(CSeqFeatData::eSubtype_any));
}

void CFeatureFieldNamePanel::ListPresentFeaturesFirst(objects::CSeq_entry_Handle seh, vector<const objects::CFeatListItem *> *featlist)
{
    if (!m_FeatureType)
        return;
    m_FeatureType->ListPresentFeaturesFirst(seh, featlist);
}

void CFeatureFieldNamePanel::ClearValues()
{
    m_FeatureType->ClearValues();
    m_QualifierName->SetSelection(wxNOT_FOUND);
    m_QualifierName->SetFirstItem(0);
}

wxArrayString CFeatureFieldNamePanel::s_FillFeatQualList(CSeqFeatData::ESubtype subtype)
{
    vector<string> names;
    for (auto qual : CSeqFeatData::GetLegalQualifiers(subtype))
    {
        if (subtype == CSeqFeatData::eSubtype_any || !CSeqFeatData::IsDiscouragedQual(qual))
            names.push_back(CSeqFeatData::GetQualifierAsString(qual));
    }
   
    wxArrayString list;
    bool product_present = false;
    bool note_present = false;
    for (auto &name : names)
    {
        NStr::ReplaceInPlace(name, "_","-");
        if (NStr::EqualNocase(name, "gene")) 
        {
            name = "locus";
        }
        if (NStr::EqualNocase(name, "product"))
        {
            product_present = true;
            continue;
        }
        if (NStr::EqualNocase(name, "note")) 
        {
            note_present = true;
            continue;
        }
        if (NStr::EqualNocase(name, "satellite-type") || (NStr::EqualNocase(name, "satellite-name")) 
            || (NStr::EqualNocase(name, "mobile-element-type-type"))  || (NStr::EqualNocase(name, "mobile-element-type-name")) )
        {
            continue;
        }
        if (NStr::EqualNocase(name, "trans-splicing")) 
        {
            continue;
        }
        list.Add(wxString(name));
        if (NStr::EqualNocase(name, "satellite"))
        {
            list.Add(wxString("satellite-type"));
            list.Add(wxString("satellite-name"));
        }
        if (NStr::EqualNocase(name, "mobile-element-type"))
        {
            list.Add(wxString("mobile-element-type-type"));
            list.Add(wxString("mobile-element-type-name"));
        }
    }
    list.Sort();
    if (note_present)
        list.Insert(_T("note"), 0);
    if (product_present)
        list.Insert(_T("product"), 0);
    return list;
}

string CFeatureFieldNamePanel::GetMacroFieldName(const string &target, const string& selected_field)
{
    string str;
    string field = GetQualifierName();
    string feature = GetFeatureType();

    if (NStr::EqualNocase(feature, "CDS")) {
        feature = "cdregion";
    }
    if (NStr::EqualNocase(feature, "preRNA")) {
        feature = "precursor_RNA";
    }

    if (NStr::EqualNocase(feature, "misc_RNA")) {
        feature = "miscRNA";
    }

    if (field == "gene" || field == "locus")
    {
        if (NStr::EqualNocase(feature, "gene"))
            str = "\"data.gene.locus\"";
        else   
            str = "\"qual\", \"locus\"";
    }
    
    if (field == "product" || field == "name")
    {
        if (NStr::EqualNocase(feature, "mRNA") || 
            NStr::EqualNocase(feature, "rRNA") ||
            NStr::EqualNocase(feature, "preRNA") ||
            NStr::EqualNocase(feature, "precursor_RNA"))
            str = "\"data.rna.ext.name\"";
        else if (NStr::EqualNocase(feature, "miscRNA") ||
            NStr::EqualNocase(feature, "ncRNA") ||
            NStr::EqualNocase(feature, "tmRNA"))
            str = "\"data.rna.ext.gen.product\"";
        else if (NStr::EqualNocase(feature, "protein"))
            str = "\"data.prot.name\"";
        else if (NStr::EqualNocase(feature, "cdregion"))
        {
            feature = "protein";
            str = "\"data.prot.name\"";
        }
    }

    if (field == "note")
    {
        str = "\"comment\"";
    }

    if (field == "db_xref")
        str = "\"dbxref.db\"";

    if (field == "desc" || field == "description")
    {
        if (NStr::EqualNocase(feature, "gene"))
            str = "\"data.gene.desc\"";
        else if (NStr::EqualNocase(feature, "protein"))
            str = "\"data.prot.desc\"";
        else 
            str = "\"qual\", \"description\"";
    }

    if (NStr::EqualNocase(feature, "gene")) {
        if (macro::NMacroUtil::StringsAreEquivalent(field, "locus-tag")) {
            str = "\"data.gene.locus-tag\"";
        }
        else if (field == "synonym") {
            str = "\"data.gene.syn\"";
        }
        else if (field == "allele") {
            str = "\"data.gene.allele\"";
        }
    }

    if (field == "activity") {
        if (NStr::EqualNocase(feature, "protein"))
            str = "\"data.prot.activity\"";
        else if (NStr::EqualNocase(feature, "cdregion"))
        {
            feature = "protein";
            str = "\"data.prot.activity\"";
        }
    }

    if (macro::NMacroUtil::StringsAreEquivalent(field, "ec-number")) {
        if (NStr::EqualNocase(feature, "protein"))
            str = "\"data.prot.ec\"";
        else if (NStr::EqualNocase(feature, "cdregion"))
        {
            feature = "protein";
            str = "\"data.prot.ec\"";
        }
    }
    if (macro::NMacroUtil::StringsAreEquivalent(field, "tag_peptide")) {
        if (NStr::EqualNocase(feature, "tmRNA")) {
            str = "\"data.rna.ext.gen.quals\", \"" + field + "\"";
        }
    }

    if (field == "translation")
    {
        if (NStr::EqualNocase(feature, "cdregion"))
            str = "TRANSLATION()";
    }

    if (field == "satellite_type") {
        str = macro::CMacroFunction_SatelliteType::GetFuncName() + "()";
    }
    else if (field == "satellite_name") {
        str = macro::CMacroFunction_SatelliteName::GetFuncName() + "()";
    }
    else if (field == "mobile_element_type_type") {
        str = macro::CMacroFunction_MobileElementType::GetFuncName() + "()";
    }
    else if (field == "mobile_element_type_name") {
        str = macro::CMacroFunction_MobileElementName::GetFuncName() + "()";
    }
    
   if (str.empty())
       str = "\"qual\", \"" + field + "\"";

   if (NStr::EqualNocase(target, feature)) {
       return str;
   }
   else {
       if (!selected_field.empty() && !NStr::EqualNocase(target, selected_field)) {
           if (NStr::EqualNocase(selected_field, feature) ||
               (selected_field == "preRNA" && feature == "precursor_RNA")) {
               return str;
           }
       }
   }

   if (NStr::EqualNocase(feature, "cdregion")) {
       feature = "cds";
   }

   if (CFieldNamePanel::IsFeature(target))
   {
       str = "RELATED_FEATURE(\"" + feature + "\", " + str + ")";
       return str;
   }
   str = "FEATURES(\"" + feature + "\"," + str + ")";
   return str;
}

/*!
 * Should we show tooltips?
 */

bool CFeatureFieldNamePanel::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap CFeatureFieldNamePanel::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CFeatureFieldNamePanel bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CFeatureFieldNamePanel bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon CFeatureFieldNamePanel::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CFeatureFieldNamePanel icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CFeatureFieldNamePanel icon retrieval
}


/*!
 * wxEVT_COMMAND_LISTBOX_SELECTED event handler for ID_QUALIFIER_LISTBOX
 */

void CFeatureFieldNamePanel::OnQualifierListboxSelected( wxCommandEvent& event )
{
    x_UpdateParent();
    event.Skip();
}


string CFeatureFieldNamePanel::GetFeatureType()
{
    string feat = "";

    if (m_Sibling) {
        feat = m_Sibling->GetFeatureType();
    } else {
        feat = m_FeatureType->GetFieldName();
    }
    return feat;
}


bool CFeatureFieldNamePanel::SetFeatureType(const string& feature_type)
{
    bool rval = false;
    if (m_Sibling) {
        rval = m_Sibling->SetFeatureType(feature_type);
    } else {
        rval = m_FeatureType->SetFieldName(feature_type);
    }
    return rval;
}


string CFeatureFieldNamePanel::GetQualifierName()
{
    string qual_name = "";
    int qual_val = m_QualifierName->GetSelection();
    if (qual_val > -1) {
        qual_name = ToStdString(m_QualifierName->GetString(qual_val));
        NStr::ReplaceInPlace(qual_name,"-","_");
    }
    return qual_name;
}


string CFeatureFieldNamePanel::GetFieldName(const bool subfield)
{
    string field = "";
    string feat = GetFeatureType();
    string qual = GetQualifierName();

    if (!NStr::IsBlank(feat) && !NStr::IsBlank(qual)) {
        field = feat + " " + qual;
    }
    if (subfield && !NStr::IsBlank(qual)) {
        field = qual;
    }

    return field;
}


bool CFeatureFieldNamePanel::SetFieldName(const string& field)
{
    bool rval = false;

    // First field may have embeddeed blanks. second does not,
    // so we locate last space
    size_t pos = NStr::Find(field, " ", NStr::eCase, NStr::eReverseSearch);
    if (pos != string::npos) {
        string feat = field.substr(0, pos);
        string qual = field.substr(pos + 1);
        rval = SetFeatureType(feat);
        if (rval) {
            NStr::ReplaceInPlace(qual, "_", "-");
            rval = m_QualifierName->SetStringSelection(ToWxString(qual));
            if (rval)
                m_QualifierName->SetFirstItem(ToWxString(qual));
        }
    }
    else
    {
        SetFeatureType(field);
    }

    return rval;
}

void CFeatureFieldNamePanel::SetShowLegalOnly(bool show)
{
    m_show_legal_only = show;
    m_FeatureType->SetShowLegalOnly(show);
}

void CFeatureFieldNamePanel::UpdateEditor()
{
    if (!m_show_legal_only)
        return;
    string field_name = GetFeatureType();
    if (field_name.empty())
        return;
    CSeqFeatData::ESubtype subtype = CSeqFeatData::SubtypeNameToValue(field_name);
    m_QualifierName->Set(s_FillFeatQualList(subtype));
}

void CFeatureFieldNamePanel::PopulateFeatureListbox()
{
    wxCommandEvent listbxEvent(wxEVT_COMMAND_UPDATE_FEATLIST, GetId());
    listbxEvent.SetEventObject(this);
    GetEventHandler()->ProcessEvent(listbxEvent);
}

vector<string> CFeatureFieldNamePanel::GetChoices(bool& allow_other)
{
    vector<string> choices;

    string field_name = GetFieldName(true);

    if (field_name == "codon_start")
    {
        choices.push_back("1");
        choices.push_back("2");
        choices.push_back("3");       
        allow_other = false;        
    }
    if (field_name == "pseudo")
    {
        choices.push_back("Processed");
        choices.push_back("Unprocessed");
        choices.push_back("Unitary");
        choices.push_back("Allelic");
        choices.push_back("Unknown");
        choices.push_back("Unqualified");
        allow_other = false;     
    }
    if (field_name == "transl_table")
    {
        const CGenetic_code_table::Tdata& codes = m_code_table.Get();
        choices.reserve(codes.size());
        ITERATE (CGenetic_code_table::Tdata, it, codes) 
        {
            string str = (*it)->GetName();
            choices.push_back(str);
        }
        allow_other = false;
    }
    return choices;
}

END_NCBI_SCOPE
