/*  $Id: dbxref_panel.cpp 37100 2016-12-05 17:10:36Z asztalos $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data,  the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties,  express or implied,  including
 *  warranties of performance,  merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors:  Colleen Bollin
 */


#include <ncbi_pch.hpp>
#include <objects/general/Object_id.hpp>

////@begin includes
////@end includes

#include "dbxref_panel.hpp"
#include "singledbxref_subpanel.hpp"

////@begin XPM images
////@end XPM images

BEGIN_NCBI_SCOPE
USING_SCOPE(objects);

/*!
 * CDbxrefPanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CDbxrefPanel, wxPanel )


/*!
 * CDbxrefPanel event table definition
 */

BEGIN_EVENT_TABLE( CDbxrefPanel, wxPanel )

////@begin CDbxrefPanel event table entries
////@end CDbxrefPanel event table entries

END_EVENT_TABLE()


/*!
 * CDbxrefPanel constructors
 */

CDbxrefPanel::CDbxrefPanel()
{
    Init();
}

CDbxrefPanel::CDbxrefPanel( wxWindow* parent, CSerialObject& object, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
    : m_Object(&object)
{
    Init();
    x_UpdateXrefs();
    Create(parent, id, caption, pos, size, style);
}

void CDbxrefPanel::x_UpdateXrefs()
{
    //m_Object = dynamic_cast<CSeq_feat*>(&object);
    m_Xrefs.clear();
    const CSeq_feat* feat = dynamic_cast<const CSeq_feat*>(m_Object);
    if (feat) {
        if (feat->IsSetDbxref()) {
            CSeq_feat::TDbxref::const_iterator it = feat->GetDbxref().begin();
            while (it != feat->GetDbxref().end()) {
                CRef< CDbtag > tag(new CDbtag());
                tag->Assign(**it);
                m_Xrefs.push_back(tag);
                ++it;
            }
        }
    } else {
        const COrg_ref* org = dynamic_cast<const COrg_ref*>(m_Object);
        if (org) {
            if (org->IsSetDb()) {
                COrg_ref::TDb::const_iterator it = org->GetDb().begin();
                while (it != org->GetDb().end()) {
                    CRef< CDbtag > tag(new CDbtag());
                    tag->Assign(**it);
                    m_Xrefs.push_back(tag);
                    ++it;
                }
            }
        }
    }
}

/*!
 * CDbxrefPanel creator
 */

bool CDbxrefPanel::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CDbxrefPanel creation
    SetExtraStyle(wxWS_EX_BLOCK_EVENTS);
    wxPanel::Create( parent, id, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CDbxrefPanel creation
    return true;
}


/*!
 * CDbxrefPanel destructor
 */

CDbxrefPanel::~CDbxrefPanel()
{
////@begin CDbxrefPanel destruction
////@end CDbxrefPanel destruction
}


/*!
 * Member initialisation
 */

void CDbxrefPanel::Init()
{
////@begin CDbxrefPanel member initialisation
    m_ScrolledWindow = NULL;
    m_Sizer = NULL;
////@end CDbxrefPanel member initialisation
}


/*!
 * Control creation for CDbxrefPanel
 */

void CDbxrefPanel::CreateControls()
{    
////@begin CDbxrefPanel content construction
    // Generated by DialogBlocks, 30/12/2011 08:04:17 (unregistered)

    CDbxrefPanel* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemPanel1->SetSizer(itemBoxSizer2);

    wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(itemBoxSizer3, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxStaticText* itemStaticText4 = new wxStaticText( itemPanel1, wxID_STATIC, _("Database"), wxDefaultPosition, wxSize(100, -1), 0 );
    itemBoxSizer3->Add(itemStaticText4, 0, wxALIGN_CENTER_VERTICAL|wxALL, 0);

    wxStaticText* itemStaticText5 = new wxStaticText( itemPanel1, wxID_STATIC, _("Object ID"), wxDefaultPosition, wxSize(100, -1), 0 );
    itemBoxSizer3->Add(itemStaticText5, 0, wxALIGN_CENTER_VERTICAL|wxALL, 0);

    m_ScrolledWindow = new wxScrolledWindow( itemPanel1, ID_SCROLLEDWINDOW2, wxDefaultPosition, wxSize(200, 100), wxSUNKEN_BORDER|wxHSCROLL|wxVSCROLL );
    itemBoxSizer2->Add(m_ScrolledWindow, 1, wxALIGN_CENTER_HORIZONTAL|wxALL, 0);
    m_ScrolledWindow->SetScrollbars(1, 1, 0, 0);
    m_Sizer = new wxBoxSizer(wxVERTICAL);
    m_ScrolledWindow->SetSizer(m_Sizer);

    m_ScrolledWindow->FitInside();

////@end CDbxrefPanel content construction
}


wxWindow* CDbxrefPanel::x_AddRow(CRef<CDbtag> tag)
{
    wxWindow* row = new CSingleDbxref_SubPanel(m_ScrolledWindow, *tag);
    m_Sizer->Add(row, 0, wxALIGN_LEFT|wxALL, 0);
    int row_width;
    int row_height;
    row->GetSize(&row_width, &row_height);
    if (row_width > m_TotalWidth) {
        m_TotalWidth = row_width;
    }
    m_TotalHeight += row_height;
    m_ScrollRate = row_height;
    m_NumRows++;
    return row;
}


bool CDbxrefPanel::TransferDataToWindow()
{
    Freeze();
    while (m_Sizer->GetItemCount() > 0) {
        size_t pos = 0;
        m_Sizer->GetItem(pos)->DeleteWindows();
        m_Sizer->Remove(pos);
    }
    m_TotalHeight = 0;
    m_TotalWidth = 0;
    m_NumRows = 0;
    m_ScrollRate = 0;

    x_UpdateXrefs();
    vector< CRef< objects::CDbtag > >::iterator it = m_Xrefs.begin();
    vector<wxWindow*> rows_to_update;
    while (it != m_Xrefs.end()) {
        rows_to_update.push_back(x_AddRow (*it));
        ++it;
    }
    ITERATE(vector<wxWindow*>, it, rows_to_update) {
        (*it)->TransferDataToWindow();
    }
    CRef<CDbtag> last_tag (new CDbtag());
    x_AddRow (last_tag);
    m_ScrolledWindow->SetVirtualSize(m_TotalWidth + 10, m_TotalHeight);
    m_ScrolledWindow->SetScrollRate(0, m_ScrollRate);
    m_ScrolledWindow->FitInside();
    Layout();
    Thaw();

    if (!wxPanel::TransferDataToWindow())
        return false;
    return true;
}


bool CDbxrefPanel::TransferDataFromWindow()
{
    if (!wxPanel::TransferDataFromWindow())
        return false;

    m_Xrefs.clear();

    wxSizerItemList::iterator node = m_Sizer->GetChildren().begin();
    for (; node != m_Sizer->GetChildren().end(); ++node) {
        wxWindow *w = (*node)->GetWindow();
        if (!w) {
            continue;
        }
        CRef<CDbtag> edited_tag;
        CSingleDbxref_SubPanel* singlexref_panel = dynamic_cast<CSingleDbxref_SubPanel*> (w);
        if (singlexref_panel) {
            edited_tag = singlexref_panel->GetDbtag();
            m_Xrefs.push_back(edited_tag);
        }
    }
    return true;
}


static bool s_HasTag (CDbtag& tag)
{
    bool rval = false;

    if (tag.IsSetTag()) {
        if (tag.GetTag().IsStr() && !NStr::IsBlank(tag.GetTag().GetStr())) {
            rval = true;
        } else if (tag.GetTag().IsId()) {
            rval = true;
        }
    }
    return rval;
}


void CDbxrefPanel::PopulateDbxrefs(CSeq_feat& seq_feat)
{
    TransferDataFromWindow();
    
    seq_feat.ResetDbxref();

    for (CSeq_feat::TDbxref::iterator x = m_Xrefs.begin();
         x != m_Xrefs.end();
         x++) {
        if ((*x)->IsSetDb() || s_HasTag(**x)) {
            CRef<CDbtag> new_tag(new CDbtag());
            new_tag->Assign(**x);
            seq_feat.SetDbxref().push_back(new_tag);
        }
    }
}


void CDbxrefPanel::PopulateDbxrefs(COrg_ref& org)
{
    TransferDataFromWindow();
    
    org.ResetDb();

    for (COrg_ref::TDb::iterator x = m_Xrefs.begin();
         x != m_Xrefs.end();
         x++) {
        if ((*x)->IsSetDb() || s_HasTag(**x)) {
            CRef<CDbtag> new_tag(new CDbtag());
            new_tag->Assign(**x);
            org.SetDb().push_back(new_tag);
        }
    }
}

void CDbxrefPanel::DeleteTaxonRef()
{
	ERASE_ITERATE (COrg_ref::TDb, db, m_Xrefs) {
		if ((*db)->IsSetDb() && NStr::Equal((*db)->GetDb(), "taxon", NStr::eNocase)) {
			VECTOR_ERASE(db, m_Xrefs);
		}
	}
	
	wxSizerItemList::iterator node = m_Sizer->GetChildren().begin(); 
	size_t pos = 0;
	int row_width, row_height;
	vector<size_t> removed_pos;
	for (node; node !=  m_Sizer->GetChildren().end(); ++node, ++pos) {
		wxWindow *w = (*node)->GetWindow();
		if (w) {
			CSingleDbxref_SubPanel* singlexref_panel = dynamic_cast<CSingleDbxref_SubPanel*> (w);
			if (singlexref_panel) {
				CRef<CDbtag> tag = singlexref_panel->GetDbtag();
				if (tag && tag->IsSetDb() && NStr::Equal(tag->GetDb(), "taxon", NStr::eNocase)) {
					singlexref_panel->GetSize(&row_width, &row_height);
					removed_pos.push_back(pos);
				}
			}
		}
	}
	
	if ( ! removed_pos.empty()) {
		for (pos = 0; pos < removed_pos.size(); ++pos) {
			m_Sizer->GetItem(removed_pos[pos])->DeleteWindows();
			m_Sizer->Remove(removed_pos[pos]);
			m_TotalHeight -= row_height;
			m_NumRows--;
			m_ScrolledWindow->SetVirtualSize(m_TotalWidth +10, m_TotalHeight);
			m_ScrolledWindow->FitInside();
			m_Sizer->Layout();
			m_ScrolledWindow->Refresh();
		}
		Layout();
	}	
}

/*!
 * Should we show tooltips?
 */

bool CDbxrefPanel::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap CDbxrefPanel::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CDbxrefPanel bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CDbxrefPanel bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon CDbxrefPanel::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CDbxrefPanel icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CDbxrefPanel icon retrieval
}


static bool s_IsLastRow(wxWindow* wnd, wxSizerItemList& itemList)
{
    bool is_last = false;
    if (NULL == wnd)
        return false;

    for(wxSizerItemList::iterator it = itemList.begin(); it != itemList.end(); ++it) {
        wxWindow* child = (**it).GetWindow();
        if (child && child == wnd) {
            is_last = true;
        } else {
            if (is_last) {
                is_last = false;
                return is_last;
            }
        }
    }

    return is_last;
}


void CDbxrefPanel::AddLastDbxref (wxWindow* link)
{
    // find the row that holds the author to be deleted
    wxSizerItemList& itemList = m_Sizer->GetChildren();

    if (s_IsLastRow(link, itemList)) {
        TransferDataFromWindow();
        CRef<CDbtag> last_tag (new CDbtag());
        m_Xrefs.push_back(last_tag);
        x_AddRow (last_tag);
        m_ScrolledWindow->SetVirtualSize(m_TotalWidth + 10, m_TotalHeight);
        m_ScrolledWindow->SetScrollRate(0, m_ScrollRate);
        m_ScrolledWindow->FitInside();
    }
}


END_NCBI_SCOPE
