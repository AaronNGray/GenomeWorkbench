/*  $Id: seqtechdlg.cpp 42186 2019-01-09 19:34:50Z asztalos $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data,  the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties,  express or implied,  including
 *  warranties of performance,  merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors:  Colleen Bollin
 */


#include <ncbi_pch.hpp>

////@begin includes
////@end includes

#include <gui/packages/pkg_sequence_edit/seqtechdlg.hpp>
#include <gui/packages/pkg_sequence_edit/subprep_panel.hpp>
#include <objmgr/bioseq_ci.hpp>
#include <objmgr/seqdesc_ci.hpp>
#include <objects/general/User_field.hpp>
#include <objects/general/Object_id.hpp>
#include <gui/objutils/cmd_create_desc.hpp>
#include <gui/objutils/cmd_del_desc.hpp>
#include <gui/objutils/descriptor_change.hpp>

#include <wx/button.h>

////@begin XPM images
////@end XPM images

BEGIN_NCBI_SCOPE

static const string kRawOrAssembled = "Raw or Assembled";
static const string kRaw = "Raw";
static const string kAssembled = "Assembled";

/*!
 * CSeqTechDlg type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CSeqTechDlg, wxFrame )


/*!
 * CSeqTechDlg event table definition
 */

BEGIN_EVENT_TABLE( CSeqTechDlg, wxFrame )

////@begin CSeqTechDlg event table entries
    EVT_RADIOBUTTON( ID_RAW_BTN, CSeqTechDlg::OnRawBtnSelected )

    EVT_RADIOBUTTON( ID_ASSEMBLED_BTN, CSeqTechDlg::OnAssembledBtnSelected )

////@end CSeqTechDlg event table entries

END_EVENT_TABLE()


/*!
 * CSeqTechDlg constructors
 */

CSeqTechDlg::CSeqTechDlg()
{
    Init();
}

CSeqTechDlg::CSeqTechDlg( wxWindow* parent, objects::CSeq_entry_Handle seh, CSourceRequirements::EWizardType wizard_type,
                          wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
: m_TopSeqEntry(seh), m_WizardType(wizard_type)
{
    m_EditedObj = new objects::CUser_object();
    x_GetSeqTechUserFromSeqEntry();

    Init();
    Create(parent, id, caption, pos, size, style);
}


/*!
 * SeqTechDlg creator
 */

bool CSeqTechDlg::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CSeqTechDlg creation
    SetExtraStyle(wxWS_EX_BLOCK_EVENTS);
    wxFrame::Create( parent, id, caption, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CSeqTechDlg creation
    return true;
}


/*!
 * CSeqTechDlg destructor
 */

CSeqTechDlg::~CSeqTechDlg()
{
////@begin CSeqTechDlg destruction
////@end CSeqTechDlg destruction
}


/*!
 * Member initialisation
 */

void CSeqTechDlg::Init()
{
////@begin CSeqTechDlg member initialisation
    m_PanelSizer = NULL;
    m_RawBtn = NULL;
    m_AssembledBtn = NULL;
////@end CSeqTechDlg member initialisation
}


/*!
 * Control creation for SeqTechDlg
 */

void CSeqTechDlg::CreateControls()
{    
////@begin CSeqTechDlg content construction
    // Generated by DialogBlocks, 10/06/2013 17:57:02 (unregistered)

    CSeqTechDlg* itemDialog1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemDialog1->SetSizer(itemBoxSizer2);

    m_PanelSizer = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(m_PanelSizer, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxStaticBox* itemStaticBoxSizer4Static = new wxStaticBox(itemDialog1, wxID_ANY, _("These sequence(s) are"));
    wxStaticBoxSizer* itemStaticBoxSizer4 = new wxStaticBoxSizer(itemStaticBoxSizer4Static, wxHORIZONTAL);
    itemBoxSizer2->Add(itemStaticBoxSizer4, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    m_RawBtn = new wxRadioButton( itemDialog1, ID_RAW_BTN, _("raw sequence reads (not assembled)"), wxDefaultPosition, wxDefaultSize, 0 );
    m_RawBtn->SetValue(false);
    itemStaticBoxSizer4->Add(m_RawBtn, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_AssembledBtn = new wxRadioButton( itemDialog1, ID_ASSEMBLED_BTN, _("assembled sequences"), wxDefaultPosition, wxDefaultSize, 0 );
    m_AssembledBtn->SetValue(false);
    itemStaticBoxSizer4->Add(m_AssembledBtn, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer7 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(itemBoxSizer7, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton8 = new wxButton( itemDialog1, wxID_OK, _("Accept"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer7->Add(itemButton8, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton9 = new wxButton( itemDialog1, wxID_CANCEL, _("Cancel"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer7->Add(itemButton9, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

////@end CSeqTechDlg content construction

    m_Panel = new CSequencingTechnologyPanel( itemDialog1, m_EditedObj, wxID_ANY, wxDefaultPosition, wxSize(100, 100), wxSIMPLE_BORDER );
    m_Panel->TransferDataToWindow();
    m_PanelSizer->Add(m_Panel, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    string raw_or_assembled = CSubPrep_panel::GetWizardFieldFromSeqEntry (m_TopSeqEntry, kRawOrAssembled);
    if (NStr::EqualNocase(raw_or_assembled, kRaw)) {
        m_RawBtn->SetValue(true);
    } else if (NStr::EqualNocase(raw_or_assembled, kAssembled)) {
        m_AssembledBtn->SetValue(true);
    }

}


/*!
 * Should we show tooltips?
 */

bool CSeqTechDlg::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap CSeqTechDlg::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CSeqTechDlg bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CSeqTechDlg bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon CSeqTechDlg::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CSeqTechDlg icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CSeqTechDlg icon retrieval
}


bool CSeqTechDlg::x_IsSpecialTech(string tech)
{
    if (NStr::IsBlank(tech)) {
        return false;
    }
    vector<string> values;
    NStr::Split(tech, ";", values);

    ITERATE(vector<string>, it, values) {
        if (!NStr::EqualNocase(*it, "Sanger dideoxy sequencing") && !NStr::StartsWith(*it, "ABI", NStr::eNocase)) {
            return false;
        }
    }
    return true;
}


static string s_BadAssemblyPrograms[] = { 
  "Assembly program", 
  "No", 
  "Yes", 
  "Not Applicable", 
  "N/A", 
  "Sequencing", 
  "PCR", 
  "PCR product", 
  "Overlapping sequence", 
  "Overlapping sequences"};

static const int k_NumBadAssemblyPrograms = sizeof (s_BadAssemblyPrograms) / sizeof (string);

string s_IsAssemblyMethodValid (string assem)
{
    if (NStr::FindNoCase(assem, "BLAST") != string::npos) {
        return "BLAST is not an assembly program. Please provide valid assembly program information.";
    } else {
        string program = assem;
        size_t pos = NStr::FindNoCase(assem, " v. ");
        if (pos != string::npos) {
            program = assem.substr(0, pos);
        }
        for (int i = 0; i < k_NumBadAssemblyPrograms; i++) {
            if (NStr::EqualNocase(program, s_BadAssemblyPrograms[i])) {
                return  "The assembly program name is not valid. Please enter the name of the program used to assemble these sequences.";
            }
        }
        if (pos == string::npos) {
            return "You must provide the version as well as the name of the assembly program.";
        }
    }
    return "";
}


static string s_BadMethods[] = { 
  "core", 
  "core facility", 
  "core lab", 
  "Sequencing", 
  "PCR", 
  "PCR product", 
  "Overlapping sequence", 
  "Overlapping sequences"
};

static const int k_NumBadMethods = sizeof (s_BadMethods) / sizeof (string);


bool s_IsBadMethod (string method)
{
    for (int i = 0; i < k_NumBadMethods; i++) {
        if (NStr::EqualNocase(s_BadMethods[i], method)) {
            return true;
        }
    }
    return false;
}


static string s_GetFieldValFromUserObj(CRef<objects::CUser_object> user, string field_name)
{
    string val = "";
    try {
        const objects::CUser_field& field = user->GetField(field_name);
        if (field.IsSetData() && field.GetData().IsStr()) {
            val = field.GetData().GetStr();
        }
    } catch (const exception&) {
    }
    return val;
}


string CSeqTechDlg::CheckSequencingTechnology(CRef<objects::CUser_object> user, CSourceRequirements::EWizardType wizard_type, string raw_or_assembled)
{
    string seq_tech = s_GetFieldValFromUserObj(user, "Sequencing Technology");
    if (NStr::IsBlank(seq_tech)) {
        return "Missing Sequencing Technology!";
    }

    if (x_IsSpecialTech(seq_tech) && wizard_type != CSourceRequirements::eWizardType_tsa) {
        return "";
    } else if (NStr::IsBlank(raw_or_assembled)) {
        return "You must select whether the sequences are assembled or raw.";
    } else if (NStr::EqualNocase(raw_or_assembled, kRaw)) {
        if (x_IsSpecialTech(seq_tech) && wizard_type == CSourceRequirements::eWizardType_tsa) {
            return "Do not use TSA wizard for unassembled Sanger or ABI sequences";
        } else {
            return "Raw sequence reads generated by next generation sequencing technologies should be submitted to the Sequence Read Archive (SRA), not GenBank. Please see: https://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi";
        }
    }

    string assem = s_GetFieldValFromUserObj(user, "Assembly Method");
    string coverage = s_GetFieldValFromUserObj(user, "Coverage");
    string a_name = s_GetFieldValFromUserObj(user, "Assembly Name");

    if (NStr::IsBlank (assem)) {
      return "Please provide the assembly program and version in the form.";
    } else if (NStr::FindNoCase(coverage, "BLAST") != string::npos) {
      return "BLAST is not an assembly program. Please provide valid assembly program information.";
    } 
    
    string problem = s_IsAssemblyMethodValid(assem);
    if (!NStr::IsBlank(problem)) {
        return problem;
    }
    if (NStr::EqualNocase(seq_tech, "Sequencing Technology")) {
        return "Sequencing technology is not a valid answer. Please enter the specific type of technology used to obtain these sequences.";
    }

    if (s_IsBadMethod(seq_tech)) {
        return "'" + seq_tech + "' is not a sequencing technology. Please only enter the type of technology that was used to generate your sequences.";
    }

    return "";
}


string CSeqTechDlg::x_GetRawOrAssembled()
{
    string raw_or_assembled = "";
    if (m_RawBtn->GetValue()) {
        raw_or_assembled = kRaw;
    } else if (m_AssembledBtn->GetValue()) {
        raw_or_assembled = kAssembled;
    }
    return raw_or_assembled;
}


CRef<CCmdComposite> CSeqTechDlg::GetCommand()
{
    CRef<CCmdComposite> cmd(new CCmdComposite("Bulk Sequencing Technology Edit") );

    m_Panel->TransferDataFromWindow();
    m_EditedObj->Assign(*(m_Panel->GetUser_object()));

    string raw_or_assembled = x_GetRawOrAssembled();

    string problem = CheckSequencingTechnology(m_EditedObj, m_WizardType, raw_or_assembled);
    if (!NStr::IsBlank(problem)) {
        CRef<CCmdComposite> empty(NULL);
        return empty;
    }

    objects::CBioseq_CI b_iter(m_TopSeqEntry, objects::CSeq_inst::eMol_na);
    for ( ; b_iter ; ++b_iter ) {
        CRef<objects::CSeqdesc> new_desc( new objects::CSeqdesc );
        CRef<objects::CUser_object> new_user (new objects::CUser_object());
        new_user->Assign (*m_EditedObj);
        new_desc->SetUser(*new_user);
        bool found = false;

        for (objects::CSeqdesc_CI desc_ci( *b_iter, objects::CSeqdesc::e_User);
             desc_ci && !found;
             ++desc_ci) {
            const objects::CUser_object& u = desc_ci->GetUser();
            if (u.IsSetType() && u.GetType().IsStr() && NStr::EqualNocase(u.GetType().GetStr(), "StructuredComment")) {
                try {
                    const objects::CUser_field& prefix = desc_ci->GetUser().GetField("StructuredCommentPrefix");
                    if (prefix.IsSetData() && prefix.GetData().IsStr()
                        && NStr::EqualNocase(prefix.GetData().GetStr(), "##Assembly-Data-START##")) {

                        CRef<CCmdChangeSeqdesc> ecmd(new CCmdChangeSeqdesc(desc_ci.GetSeq_entry_Handle(), *desc_ci, *new_desc));
                        cmd->AddCommand (*ecmd);
                        found = true;
                    }
                } catch (const exception&) {
                }
            }            
        }
        if (!found) {
            objects::CBioseq_set_Handle bssh = b_iter->GetParentBioseq_set();
            if (bssh && bssh.IsSetClass() && bssh.GetClass() == objects::CBioseq_set::eClass_nuc_prot) {
                cmd->AddCommand( *CRef<CCmdCreateDesc>(new CCmdCreateDesc(bssh.GetParentEntry(), *new_desc)) );
            } else {
                cmd->AddCommand( *CRef<CCmdCreateDesc>(new CCmdCreateDesc(b_iter->GetParentEntry(), *new_desc)) );
            }
        }
    }
    cmd->AddCommand( *CSubPrep_panel::SetWizardFieldInSeqEntry(m_TopSeqEntry, kRawOrAssembled, raw_or_assembled));
    return cmd;
}


string CSeqTechDlg::GetErrorMessage()
{
    m_Panel->TransferDataFromWindow();
    m_EditedObj->Assign(*(m_Panel->GetUser_object()));
    string raw_or_assembled = x_GetRawOrAssembled();

    string problem = CheckSequencingTechnology(m_EditedObj, m_WizardType, raw_or_assembled);

    if (NStr::IsBlank(problem)) {
        problem = "Unknown error";
    }
    return problem;
}


void CSeqTechDlg::x_GetSeqTechUserFromSeqEntry()
{
    objects::CBioseq_CI b_iter(m_TopSeqEntry, objects::CSeq_inst::eMol_na);
    for ( ; b_iter ; ++b_iter ) {
        objects::CSeqdesc_CI it (*b_iter, objects::CSeqdesc::e_User);
        while (it ) {
            if (it->GetUser().IsSetType() 
                && it->GetUser().GetType().IsStr()
                && NStr::EqualNocase(it->GetUser().GetType().GetStr(), "StructuredComment")) {
                ITERATE (objects::CUser_object::TData, field_it, it->GetUser().GetData()) {
                    if ((*field_it)->IsSetLabel() 
                         && (*field_it)->GetLabel().IsStr()
                         && NStr::EqualNocase((*field_it)->GetLabel().GetStr(), "StructuredCommentPrefix")
                         && (*field_it)->IsSetData()
                         && (*field_it)->GetData().IsStr()
                         && NStr::EqualNocase((*field_it)->GetData().GetStr(), "##Assembly-Data-START##")) {
                        m_EditedObj->Assign (it->GetUser());
                        return;
                        // TODO: combine multiples...
                    }
                }
            }
            ++it;
        }
    }
    m_EditedObj->SetType().SetStr("StructuredComment");
    objects::CUser_field& prefix = m_EditedObj->SetField("StructuredCommentPrefix");
    prefix.SetData().SetStr("##Assembly-Data-START##");
    objects::CUser_field& suffix = m_EditedObj->SetField("StructuredCommentSuffix");
    suffix.SetData().SetStr("##Assembly-Data-END##");
}


/*!
 * wxEVT_COMMAND_RADIOBUTTON_SELECTED event handler for ID_RAW_BTN
 */

void CSeqTechDlg::OnRawBtnSelected( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_RADIOBUTTON_SELECTED event handler for ID_RAW_BTN in CSeqTechDlg.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_RADIOBUTTON_SELECTED event handler for ID_RAW_BTN in CSeqTechDlg. 
}


/*!
 * wxEVT_COMMAND_RADIOBUTTON_SELECTED event handler for ID_ASSEMBLED_BTN
 */

void CSeqTechDlg::OnAssembledBtnSelected( wxCommandEvent& event )
{
////@begin wxEVT_COMMAND_RADIOBUTTON_SELECTED event handler for ID_ASSEMBLED_BTN in CSeqTechDlg.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_COMMAND_RADIOBUTTON_SELECTED event handler for ID_ASSEMBLED_BTN in CSeqTechDlg. 
}


END_NCBI_SCOPE
