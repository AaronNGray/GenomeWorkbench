/*  $Id: apply_edit_convert_panel.cpp 43227 2019-05-30 16:00:26Z filippov $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data,  the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties,  express or implied,  including
 *  warranties of performance,  merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors:  Igor Filippov
 */


// Generated by DialogBlocks (unregistered), 14/05/2014 15:44:27

#include <ncbi_pch.hpp>
// Generated by DialogBlocks (unregistered), 16/05/2014 10:25:31

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes
#include <gui/packages/pkg_sequence_edit/miscedit_util.hpp>
#include <gui/packages/pkg_sequence_edit/srceditdialog.hpp>
#include <gui/packages/pkg_sequence_edit/existingtextdlg.hpp>
#include <gui/packages/pkg_sequence_edit/parse_text_options_dlg.hpp>
#include <gui/packages/pkg_sequence_edit/apply_edit_convert_panel.hpp>

////@begin XPM images
////@end XPM images

BEGIN_NCBI_SCOPE


/*
 * CApplyEditconvertPanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CApplyEditconvertPanel, wxPanel )


/*
 * CApplyEditconvertPanel event table definition
 */

BEGIN_EVENT_TABLE( CApplyEditconvertPanel, wxPanel )

////@begin CApplyEditconvertPanel event table entries

    EVT_BUTTON( ID_AECR_BUTTON, CApplyEditconvertPanel::OnApplyToAllButtonClick )

    EVT_BUTTON( ID_AECR_BUTTON1, CApplyEditconvertPanel::OnApplyToSelButtonClick )

    EVT_BUTTON( ID_AECR_BUTTON2, CApplyEditconvertPanel::OnUndoButtonClick )

////@end CApplyEditconvertPanel event table entries

END_EVENT_TABLE()


/*
 * CApplyEditconvertPanel constructors
 */

CApplyEditconvertPanel::CApplyEditconvertPanel()
{
    Init();
}

CApplyEditconvertPanel::CApplyEditconvertPanel( wxWindow* parent, CSeqTableGridPanel* grid_panel, wxArrayString &choices, 
    int init_action, bool horizontal, wxWindowID id, const wxPoint& pos, const wxSize& size, long style)
    : m_GridPanel(grid_panel), m_Grid(grid_panel->GetGrid()), m_Choices(&choices), m_init_action(init_action), m_Horizontal(horizontal)
{
    Init();
    Create(parent, id, pos, size, style);
}


/*
 * CApplyEditconvertPanel creator
 */

bool CApplyEditconvertPanel::Create( wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CApplyEditconvertPanel creation
    wxPanel::Create( parent, id, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
       GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CApplyEditconvertPanel creation
    return true;
}


/*
 * CApplyEditconvertPanel destructor
 */

CApplyEditconvertPanel::~CApplyEditconvertPanel()
{
////@begin CApplyEditconvertPanel destruction
////@end CApplyEditconvertPanel destruction
}


/*
 * Member initialisation
 */

void CApplyEditconvertPanel::Init()
{
////@begin CApplyEditconvertPanel member initialisation
////@end CApplyEditconvertPanel member initialisation
    m_Modified = false;
}


/*
 * Control creation for CApplyEditconvertPanel
 */

void CApplyEditconvertPanel::CreateControls()
{    
////@begin CApplyEditconvertPanel content construction
    // Generated by DialogBlocks, 16/05/2014 14:02:36 (unregistered)

    CApplyEditconvertPanel* itemPanel1 = this;

    wxStaticBox* itemStaticBoxSizer2Static = new wxStaticBox(itemPanel1, wxID_ANY, _("Action"));
    wxStaticBoxSizer* itemStaticBoxSizer2 = new wxStaticBoxSizer(itemStaticBoxSizer2Static, wxVERTICAL);
    itemPanel1->SetSizer(itemStaticBoxSizer2);

    wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxHORIZONTAL);
    itemStaticBoxSizer2->Add(itemBoxSizer3, 1, wxALIGN_LEFT|wxALL, 5);

    m_Notebook = new wxListbook( itemStaticBoxSizer2->GetStaticBox(), ID_AECR_CHOICE, wxDefaultPosition, wxDefaultSize, wxBK_LEFT);
    itemBoxSizer3->Add(m_Notebook, 0, wxALIGN_TOP|wxALL, 5);

    CApplySubpanel *panel1 = new CApplySubpanel( m_Notebook, m_Grid, *m_Choices, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );
    m_Notebook->AddPage(panel1, _("Apply"));

    CEditSubpanel *panel2 = new CEditSubpanel( m_Notebook, m_Grid, *m_Choices, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );
    m_Notebook->AddPage(panel2, _("Edit"));
   
    CRemoveSubpanel *panel3 = new CRemoveSubpanel( m_Notebook, m_Grid, *m_Choices, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );
    m_Notebook->AddPage(panel3, _("Remove"));

    CSwapSubpanel *panel4 = new CSwapSubpanel( m_Notebook, m_Grid, *m_Choices, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );
    m_Notebook->AddPage(panel4, _("Swap"));

    CConvertSubpanel *panel5 = new CConvertSubpanel( m_Notebook, m_Grid, *m_Choices, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );
    m_Notebook->AddPage(panel5, _("Convert"));

    CParseSubpanel *panel6 = new CParseSubpanel(m_Notebook, m_Grid, *m_Choices, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL);
    m_Notebook->AddPage(panel6, _("Parse"));

    CChangeCaseSubpanel *panel7 = new CChangeCaseSubpanel( m_Notebook, m_Grid, *m_Choices, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxTAB_TRAVERSAL );
    m_Notebook->AddPage(panel7, _("Change Case"));
    
    wxBoxSizer* itemBoxSizer7 = new wxBoxSizer(wxHORIZONTAL);
    itemStaticBoxSizer2->Add(itemBoxSizer7, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 2);

    wxButton* itemButton8 = new wxButton( itemStaticBoxSizer2->GetStaticBox(), ID_AECR_BUTTON, _("Apply To All"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer7->Add(itemButton8, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton9 = new wxButton( itemStaticBoxSizer2->GetStaticBox(), ID_AECR_BUTTON1, _("Apply To Selected"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer7->Add(itemButton9, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_UndoButton = new wxButton( itemStaticBoxSizer2->GetStaticBox(), ID_AECR_BUTTON2, _("Undo"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer7->Add(m_UndoButton, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);
    m_UndoButton->Disable();

////@end CApplyEditconvertPanel content construction
}


/*
 * Should we show tooltips?
 */

bool CApplyEditconvertPanel::ShowToolTips()
{
    return true;
}

/*
 * Get bitmap resources
 */

wxBitmap CApplyEditconvertPanel::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CApplyEditconvertPanel bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CApplyEditconvertPanel bitmap retrieval
}

/*
 * Get icon resources
 */

wxIcon CApplyEditconvertPanel::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CApplyEditconvertPanel icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CApplyEditconvertPanel icon retrieval
}

wxListBox* CApplyEditconvertPanel::GetListBox()
{
    wxWindow *win =  m_Notebook->GetCurrentPage();
    CSubpanel* panel = dynamic_cast<CSubpanel*>(win);
    if (panel)
        return panel->GetListBox();
    return NULL;
}

static SrcEditDialog *GetBulkSourceFrame(wxWindow *win)
{
    while (win)
    {
        SrcEditDialog *base = dynamic_cast<SrcEditDialog*>(win);
        if (base)
            return base;
        win = win->GetParent();
    }
    return NULL;
}


int CApplyEditconvertPanel::GetColumn()
{
    int col = -1;
    int sel = GetListBox()->GetSelection();
    if (sel == wxNOT_FOUND) return col;
    for (int i=0; i < m_Grid->GetNumberCols(); i++)
        if (m_Grid->GetColLabelValue(i) == GetListBox()->GetString(sel))
        {
            col = i;
            break;
        }
    if (col == -1)
    {
        CApplyEditconvertPanel *parent = this;
        if (parent)
        {
            SrcEditDialog* w = GetBulkSourceFrame(parent);
            if (w)
                col = w->GetNewColumn(GetListBox()->GetString(sel));      
        }
    }
    return col;
}

void CApplyEditconvertPanel::GetSelectedRows(std::set<int> &selected)
{
    wxArrayInt wx_selected = m_Grid->GetSelectedRows();
    if (wx_selected.IsEmpty())
    {
            if (m_Grid->GetSelectionBlockTopLeft().size() == 1 &&  m_Grid->GetSelectionBlockTopLeft().size() == m_Grid->GetSelectionBlockBottomRight().size())
            {
                int top_row = m_Grid->GetSelectionBlockTopLeft()[0].GetRow();
                int bot_row = m_Grid->GetSelectionBlockBottomRight()[0].GetRow();
                for (int i = top_row; i <= bot_row; i++)
                {
                    selected.insert(i);
                }
            }
        }
    else
    {
        for (unsigned int i = 0; i < wx_selected.GetCount(); i++)
        {
            selected.insert(wx_selected.Item(i));
        }
    }
}

wxString CApplyEditconvertPanel::GetAutopopulateValue()
{
    wxString value;
    int collapsed_col = m_GridPanel->GetCollapseColAndExpand();
    int col = GetColumn();
    if (col < 0) 
    {
        m_GridPanel->CollapseByCol(collapsed_col);
        return value;
    }

    if (m_Grid->IsSelection())
    {
        std::set<int> selected;
        GetSelectedRows(selected);
        for (std::set<int>::const_iterator i = selected.begin(); i != selected.end(); ++i)
        {
            value = m_Grid->GetCellValue(*i,col);
            if (!value.IsEmpty())
                break;
        }
    }
    else
    {
        for (int i = 0; i < m_Grid->GetNumberRows(); i++)
        {
            value = m_Grid->GetCellValue(i,col);
            if (!value.IsEmpty())
                break;
        }   
    }
    m_GridPanel->CollapseByCol(collapsed_col);
    return value;
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_AECR_BUTTON
 */

void CApplyEditconvertPanel::OnApplyToAllButtonClick( wxCommandEvent& event )
{   
    int collapsed_col = m_GridPanel->GetCollapseColAndExpand();

    int col = GetColumn();
    if (col < 0) 
    {
        m_GridPanel->CollapseByCol(collapsed_col);
        return;
    }
    m_undo_values.clear();

    wxWindow *win =  m_Notebook->GetCurrentPage();
    CSubpanel* panel = dynamic_cast<CSubpanel*>(win);
    if (panel)
        panel->ApplyToAll(col);

    m_GridPanel->CollapseByCol(collapsed_col);
    if (!m_undo_values.empty())
    {
        m_UndoButton->Enable();
        m_Modified = true;
        m_Grid->Refresh();
    }
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_AECR_BUTTON1
 */

void CApplyEditconvertPanel::OnApplyToSelButtonClick( wxCommandEvent& event )
{   
    int collapsed_col = m_GridPanel->GetCollapseColAndExpand();

    int col = GetColumn();
    if (col < 0) 
    {
        m_GridPanel->CollapseByCol(collapsed_col);
        return;
    }
    if (!m_Grid->IsSelection()) 
    {
        m_GridPanel->CollapseByCol(collapsed_col);
        return;
    }
    m_undo_values.clear();
    std::set<int> selected;
    GetSelectedRows(selected);

    wxWindow *win =  m_Notebook->GetCurrentPage();
    CSubpanel* panel = dynamic_cast<CSubpanel*>(win);
    if (panel)
        panel->ApplyToSelected(col,selected);

    m_GridPanel->CollapseByCol(collapsed_col);
    if (!m_undo_values.empty())
    {
        m_UndoButton->Enable();
        m_Modified = true;
        m_Grid->Refresh();
    }
}

void CApplyEditconvertPanel::SetColumns(wxArrayString &columns)
{
    for (int i=0; i<m_Notebook->GetPageCount(); i++)
    {
        wxWindow *win = m_Notebook->GetPage(i);
        CSubpanel* panel = dynamic_cast<CSubpanel*>(win);
        if (panel)
            panel->SetColumns(columns);
    }
    Refresh();
}

void CApplyEditconvertPanel::OnUndoButtonClick( wxCommandEvent& event )
{
    int collapsed_col = m_GridPanel->GetCollapseColAndExpand();
    for (map<int, map<int,string> >::iterator i = m_undo_values.begin(); i != m_undo_values.end(); ++i)
        for (map<int,string>::iterator j = i->second.begin(); j != i->second.end(); ++j)
        {
            int row = i->first;
            int col = j->first;
            string val = j->second;
            m_Grid->SetCellTextColour(row,col, m_Grid->GetDefaultCellTextColour());
            m_Grid->SetCellValue(row,col,wxString(val));
        }
    m_UndoButton->Disable();
    m_GridPanel->CollapseByCol(collapsed_col);
}

/*
 * CSubpanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CSubpanel, wxPanel )


/*
 * CSubpanel event table definition
 */

BEGIN_EVENT_TABLE( CSubpanel, wxPanel )
END_EVENT_TABLE()

objects::edit::EExistingText CSubpanel::GetExistingTextHandling(const string &field)
{
    objects::edit::EExistingText existing_text = objects::edit::eExistingText_replace_old;

    string msg = "Do you want to overwrite existing values?";
    int answer = wxMessageBox(ToWxString(msg), wxT("Existing Text"), wxYES_NO | wxCANCEL | wxICON_QUESTION, this);
    if (answer == wxCANCEL) {
        existing_text = objects::edit::eExistingText_cancel;
    } else if (answer == wxYES) {
        existing_text = objects::edit::eExistingText_replace_old;
    } else {
        CExistingTextDlg dlg(this);
        CRef<CMiscSeqTableColumn> column(new CMiscSeqTableColumn(field));
        bool allow_add = column->AllowMultipleValues();
        dlg.AllowAdditionalQual(allow_add); 
        if (dlg.ShowModal() == wxID_OK) {
            existing_text = dlg.GetExistingTextHandler();
        } else {
            existing_text = objects::edit::eExistingText_cancel;
        }
        dlg.Close();
    }
    
    return existing_text;
}

CApplyEditconvertPanel *CSubpanel::GetBaseFrame()
{
    wxWindow *win = GetParent();
    while (win)
    {
        CApplyEditconvertPanel *base = dynamic_cast<CApplyEditconvertPanel*>(win);
        if (base)
            return base;
        win = win->GetParent();
    }
    return NULL;
}

void CSubpanel::ChangeValue(const string &new_value, int row, int col)
{
    string old_value = this->m_Grid->GetCellValue(row,col).ToStdString();
    if (old_value != new_value)
    {
        CApplyEditconvertPanel *parent = GetBaseFrame();
        if (parent)
            parent->AddUndo(row,col,old_value); 
        this->m_Grid->SetCellTextColour(row,col,wxColour(255, 160, 0));
        this->m_Grid->SetCellValue(row,col,wxString(new_value));
    }
}

int CSubpanel::GetColumn2()
{
    int col = -1;
    if (!m_ListBox2)
        return col;
    int sel = m_ListBox2->GetSelection();
    if (sel == wxNOT_FOUND) return col;
    for (int i=0; i < this->m_Grid->GetNumberCols(); i++)
        if (this->m_Grid->GetColLabelValue(i) == m_ListBox->GetString(sel))
        {
            col = i;
            break;
        }
    if (col == -1)
    {
        CApplyEditconvertPanel *parent = GetBaseFrame();
        if (parent)
        {
            SrcEditDialog* w = GetBulkSourceFrame(parent);
            if (w)
                col = w->GetNewColumn(m_ListBox->GetString(sel));       
        }
    }
    return col;
}


/*
 * CApplySubpanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CApplySubpanel, CSubpanel )


/*
 * CApplySubpanel event table definition
 */

BEGIN_EVENT_TABLE( CApplySubpanel, CSubpanel )

////@begin CApplySubpanel event table entries
    EVT_BUTTON( ID_APPLYSUB_AUTOPOPULATE, CApplySubpanel::OnApplysubAutopopulateClick )

    EVT_BUTTON( ID_APPLYSUB_CLEAR, CApplySubpanel::OnApplysubClearClick )

////@end CApplySubpanel event table entries

END_EVENT_TABLE()

/*
 * Control creation for CApplySubpanel
 */

void CApplySubpanel::CreateControls()
{    
////@begin CApplySubpanel content construction
    // Generated by DialogBlocks, 16/05/2014 16:20:02 (unregistered)

    CApplySubpanel* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxHORIZONTAL);
    itemPanel1->SetSizer(itemBoxSizer2);

    m_ListBox = new wxListBox( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, *m_Choices, wxLB_SINGLE );
    m_ListBox->SetSelection(0);
    itemBoxSizer2->Add(m_ListBox, 0, wxALIGN_TOP|wxALL, 5);   

    wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer2->Add(itemBoxSizer3, 0, wxALIGN_TOP, 0);   

    m_TextCtrl = new wxTextCtrl( itemPanel1, ID_APPLYSUB_TEXTCTRL, wxEmptyString, wxDefaultPosition, wxSize(300, -1), 0 );
    itemBoxSizer3->Add(m_TextCtrl, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer4 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer3->Add(itemBoxSizer4, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton5 = new wxButton( itemPanel1, ID_APPLYSUB_AUTOPOPULATE, _("Autopopulate"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer4->Add(itemButton5, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton6 = new wxButton( itemPanel1, ID_APPLYSUB_CLEAR, _("Clear"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer4->Add(itemButton6, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

////@end CApplySubpanel content construction
}

/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_APPLYSUB_AUTOPOPULATE
 */

void CApplySubpanel::OnApplysubAutopopulateClick( wxCommandEvent& event )
{
    CApplyEditconvertPanel *parent = NULL;
    wxWindow *win = this;
    while (win && !parent)
    {
        win  = win->GetParent();
        parent = dynamic_cast<CApplyEditconvertPanel*>(win);
    }
    if (!parent) 
        return;
    wxString value = parent-> GetAutopopulateValue();
    m_TextCtrl->SetValue(value);
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_APPLYSUB_CLEAR
 */

void CApplySubpanel::OnApplysubClearClick( wxCommandEvent& event )
{
    m_TextCtrl->Clear();
}

void CApplySubpanel::ApplyToAll(int col) 
{
    objects::edit::EExistingText method = objects::edit::eExistingText_replace_old;
    string value = m_TextCtrl->GetValue().ToStdString();
    if (value.empty())
    {
        wxMessageBox(_("Apply value is empty"), wxT("No value entered"), wxOK | wxICON_WARNING, this);
        return;
    }
    bool first = true;
    for (int i = 0; i < this->m_Grid->GetNumberRows(); i++)
        if (!this->m_Grid->IsReadOnly(i,col) && this->m_Grid->IsRowShown(i) )
        {
            string new_value = this->m_Grid->GetCellValue(i,col).ToStdString();
            if (!new_value.empty())
            {
                if (first)
                {
                    method = GetExistingTextHandling(m_Grid->GetColLabelValue(col).ToStdString());
                    first = false;
                }
            }
            if (method != objects::edit::eExistingText_cancel)
            {
                AddValueToString(new_value,value,method);  
                ChangeValue(new_value, i, col);             
            }
        }
}

void CApplySubpanel::ApplyToSelected(int col, const std::set<int> &selected) 
{
    objects::edit::EExistingText method = objects::edit::eExistingText_replace_old;
    string value = m_TextCtrl->GetValue().ToStdString();
    if (value.empty())
    {
        wxMessageBox(_("Apply value is empty"), wxT("No value entered"), wxOK | wxICON_WARNING, this);
        return;
    }
    bool first = true;
    for (std::set<int>::const_iterator i = selected.begin(); i != selected.end(); ++i)
        if (!this->m_Grid->IsReadOnly(*i,col) && this->m_Grid->IsRowShown(*i))
        {
            string new_value = this->m_Grid->GetCellValue(*i,col).ToStdString();
            if (!new_value.empty())
            {
                if (first)
                {
                    method = GetExistingTextHandling(m_Grid->GetColLabelValue(col).ToStdString());
                    first = false;
                }
            }
            if (method != objects::edit::eExistingText_cancel)
            {
                AddValueToString(new_value,value,method);  
                ChangeValue(new_value, *i, col);                   
            }
        }
}

/*
 * CEditSubpanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CEditSubpanel, CSubpanel )


/*
 * CEditSubpanel event table definition
 */

BEGIN_EVENT_TABLE( CEditSubpanel, CSubpanel )

    EVT_BUTTON( ID_EDITSUB_AUTOPOPULATE, CEditSubpanel::OnEditsubAutopopulateClick )

    EVT_BUTTON( ID_EDITSUB_CLEAR, CEditSubpanel::OnEditsubClearClick )

////@begin CEditSubpanel event table entries
    EVT_BUTTON( ID_EDITSUB_COPY, CEditSubpanel::OnEditsubCopyClick )

////@end CEditSubpanel event table entries

END_EVENT_TABLE()


/*
 * Control creation for CEditSubpanel
 */

void CEditSubpanel::CreateControls()
{    
////@begin CEditSubpanel content construction
    // Generated by DialogBlocks, 16/05/2014 18:06:49 (unregistered)

    CEditSubpanel* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxHORIZONTAL);
    itemPanel1->SetSizer(itemBoxSizer2);

    m_ListBox = new wxListBox( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, *m_Choices, wxLB_SINGLE );
    m_ListBox->SetSelection(0);
    itemBoxSizer2->Add(m_ListBox, 0, wxALIGN_TOP|wxALL, 5);   

    wxBoxSizer* itemBoxSizer4 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer2->Add(itemBoxSizer4, 0, wxALIGN_TOP|wxALL, 0);

    wxStaticText* itemStaticText5 = new wxStaticText( itemPanel1, wxID_STATIC, _("Find"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer4->Add(itemStaticText5, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxStaticText* itemStaticText6 = new wxStaticText( itemPanel1, wxID_STATIC, _("Replace"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer4->Add(itemStaticText6, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer7 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer2->Add(itemBoxSizer7, 0, wxALIGN_TOP|wxALL, 0);

    m_Find = new wxTextCtrl( itemPanel1, ID_EDITSUB_FIND, wxEmptyString, wxDefaultPosition, wxSize(250, -1), 0 );
    itemBoxSizer7->Add(m_Find, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    m_Replace = new wxTextCtrl( itemPanel1, ID_EDITSUB_REPLACE, wxEmptyString, wxDefaultPosition, wxSize(250, -1), 0 );
    itemBoxSizer7->Add(m_Replace, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer10 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer2->Add(itemBoxSizer10, 0, wxALIGN_TOP|wxALL, 0);

    wxButton* itemButton11 = new wxButton( itemPanel1, ID_EDITSUB_COPY, _("Copy"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer10->Add(itemButton11, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer12 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer7->Add(itemBoxSizer12, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 2);

    m_Anywhere = new wxRadioButton( itemPanel1, ID_EDITSUB_ANY, _("Anywhere"), wxDefaultPosition, wxDefaultSize, 0 );
    m_Anywhere->SetValue(true);
    itemBoxSizer12->Add(m_Anywhere, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_AtBegin = new wxRadioButton( itemPanel1, ID_EDITSUB_BEG, _("At the beginning"), wxDefaultPosition, wxDefaultSize, 0 );
    m_AtBegin->SetValue(false);
    itemBoxSizer12->Add(m_AtBegin, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_AtEnd = new wxRadioButton( itemPanel1, ID_EDITSUB_END, _("At the end"), wxDefaultPosition, wxDefaultSize, 0 );
    m_AtEnd->SetValue(false);
    itemBoxSizer12->Add(m_AtEnd, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer16 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer7->Add(itemBoxSizer16, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 2);

    wxButton* itemButton17 = new wxButton( itemPanel1, ID_EDITSUB_AUTOPOPULATE, _("Autopopulate"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer16->Add(itemButton17, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton18 = new wxButton( itemPanel1, ID_EDITSUB_CLEAR, _("Clear"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer16->Add(itemButton18, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

////@end CEditSubpanel content construction
}

/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_EDITSUB_COPY
 */

void CEditSubpanel::OnEditsubCopyClick( wxCommandEvent& event )
{
    wxString val = m_Find->GetValue();
    m_Replace->SetValue(val);
}

/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_EDITSUB_AUTOPOPULATE
 */

void CEditSubpanel::OnEditsubAutopopulateClick( wxCommandEvent& event )
{
    CApplyEditconvertPanel *parent = NULL;
    wxWindow *win = this;
    while (win && !parent)
    {
        win  = win->GetParent();
        parent = dynamic_cast<CApplyEditconvertPanel*>(win);
    }

    if (!parent) return;
    wxString value = parent-> GetAutopopulateValue();
    m_Find->SetValue(value);
}


/*
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_EDITSUB_CLEAR
 */

void CEditSubpanel::OnEditsubClearClick( wxCommandEvent& event )
{
    m_Find->Clear();
}

void CEditSubpanel::ApplyToAll(int col) 
{
    string find = m_Find->GetValue().ToStdString();
    if (find.empty())
    {
        wxMessageBox(_("Find value is empty"), wxT("No value entered"), wxOK | wxICON_WARNING, this);
        return;
    }
    string replace = m_Replace->GetValue().ToStdString();
    bool any = m_Anywhere->GetValue();
    bool start = m_AtBegin->GetValue();
    bool end = m_AtEnd->GetValue();

    for (int i = 0; i < this->m_Grid->GetNumberRows(); i++)
        if (!this->m_Grid->IsReadOnly(i,col) && this->m_Grid->IsRowShown(i))
        {
            string source = this->m_Grid->GetCellValue(i,col).ToStdString();
            if (any)
            {
                string new_value = NStr::Replace(source,find,replace);
                ChangeValue(new_value,i,col);
                continue;
            }
            if (start && NStr::StartsWith(source,find))
            {
                string new_value = NStr::Replace(source,find,replace,0,1);
                ChangeValue(new_value,i,col);
                continue;
            }
            if (end && NStr::EndsWith(source,find))
            {
                size_t pos = source.length() - find.length();
                string new_value = NStr::Replace(source,find,replace,pos,1);
                ChangeValue(new_value,i,col);
                continue;
            }
            
        }
    
}

void CEditSubpanel::ApplyToSelected(int col, const std::set<int> &selected) 
{
    string find = m_Find->GetValue().ToStdString();
    if (find.empty())
    {
        wxMessageBox(_("Find value is empty"), wxT("No value entered"), wxOK | wxICON_WARNING, this);
        return;
    }
    string replace = m_Replace->GetValue().ToStdString();
    bool any = m_Anywhere->GetValue();
    bool start = m_AtBegin->GetValue();
    bool end = m_AtEnd->GetValue();

    for (std::set<int>::const_iterator i = selected.begin(); i != selected.end(); ++i)
        if (!this->m_Grid->IsReadOnly(*i,col) && this->m_Grid->IsRowShown(*i))
        {
            string source = this->m_Grid->GetCellValue(*i,col).ToStdString();
            if (any)
            {
                
                string new_value = NStr::Replace(source,find,replace);
                ChangeValue(new_value,*i,col);
                continue;
            }
            if (start && NStr::StartsWith(source,find))
            {
                string new_value = NStr::Replace(source,find,replace,0,1);
                ChangeValue(new_value,*i,col);
                continue;
            }
            if (end && NStr::EndsWith(source,find))
            {
                size_t pos = source.length() - find.length();
                string new_value = NStr::Replace(source,find,replace,pos,1);
                ChangeValue(new_value,*i,col);
                continue;
            }
            
        }

}


/*
 * CRemoveSubpanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CRemoveSubpanel, CSubpanel )


/*
 * CRemoveSubpanel event table definition
 */

BEGIN_EVENT_TABLE( CRemoveSubpanel, CSubpanel )

END_EVENT_TABLE()

/*
 * Control creation for CRemoveSubpanel
 */

void CRemoveSubpanel::CreateControls()
{    
////@begin CRemoveSubpanel content construction
    // Generated by DialogBlocks, 16/05/2014 18:06:49 (unregistered)

    CRemoveSubpanel* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxHORIZONTAL);
    itemPanel1->SetSizer(itemBoxSizer2);

    m_ListBox = new wxListBox( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, *m_Choices, wxLB_SINGLE );
    m_ListBox->SetSelection(0);
    itemBoxSizer2->Add(m_ListBox, 0, wxALIGN_TOP|wxALL, 5);   
    
////@end CRemoveSubpanel content construction
}


void CRemoveSubpanel::ApplyToAll(int col) 
{ 
    for (int i = 0; i < this->m_Grid->GetNumberRows(); i++)
        if (!this->m_Grid->IsReadOnly(i,col) && this->m_Grid->IsRowShown(i))
        {
            ChangeValue(kEmptyStr,i,col);
        }
}

void CRemoveSubpanel::ApplyToSelected(int col, const std::set<int> &selected) 
{

    for (std::set<int>::const_iterator i = selected.begin(); i != selected.end(); ++i)
        if (!this->m_Grid->IsReadOnly(*i,col) && this->m_Grid->IsRowShown(*i))
        {
            ChangeValue(kEmptyStr,*i,col);
        }

}



/*
 * CSwapSubpanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CSwapSubpanel, CSubpanel )

BEGIN_EVENT_TABLE( CSwapSubpanel, CSubpanel )

END_EVENT_TABLE()

void CSwapSubpanel::CreateControls()
{    
    CSwapSubpanel* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxHORIZONTAL);
    itemPanel1->SetSizer(itemBoxSizer2);
    
    m_ListBox = new wxListBox( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, *m_Choices, wxLB_SINGLE );
    m_ListBox->SetSelection(0);
    itemBoxSizer2->Add(m_ListBox, 0, wxALIGN_TOP|wxALL, 5); 

    m_ListBox2 = new wxListBox( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, *m_Choices, wxLB_SINGLE );
    m_ListBox2->SetSelection(0);
    itemBoxSizer2->Add(m_ListBox2, 0, wxALIGN_TOP|wxALL, 5);
}


void CSwapSubpanel::ApplyToAll(int col) 
{ 
    int col2 = GetColumn2();
    if (col2 < 0 ) return;
    if (col == col2) return;

    for (int i = 0; i < this->m_Grid->GetNumberRows(); i++)
        if (!this->m_Grid->IsReadOnly(i,col) && !this->m_Grid->IsReadOnly(i,col2)  && this->m_Grid->IsRowShown(i))
        {
            wxString value =  this->m_Grid->GetCellValue(i,col);
            wxString value2 =  this->m_Grid->GetCellValue(i,col2);
            ChangeValue(value2.ToStdString(),i,col);
            ChangeValue(value.ToStdString(),i,col2);
        }
}

void CSwapSubpanel::ApplyToSelected(int col, const std::set<int> &selected) 
{
    int col2 = GetColumn2();
    if (col2 < 0 ) return;
    if (col == col2) return;

    for (std::set<int>::const_iterator i = selected.begin(); i != selected.end(); ++i)
        if (!this->m_Grid->IsReadOnly(*i,col) && !this->m_Grid->IsReadOnly(*i,col2) && this->m_Grid->IsRowShown(*i))
        {
            wxString value =  this->m_Grid->GetCellValue(*i,col);
            wxString value2 =  this->m_Grid->GetCellValue(*i,col2);
            ChangeValue(value2.ToStdString(),*i,col);
            ChangeValue(value.ToStdString(),*i,col2);
        }

}


/*
 * CConvertSubpanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CConvertSubpanel, CSubpanel )

BEGIN_EVENT_TABLE( CConvertSubpanel, CSubpanel )

END_EVENT_TABLE()

void CConvertSubpanel::CreateControls()
{    
    CConvertSubpanel* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemPanel1->SetSizer(itemBoxSizer2);

    wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(itemBoxSizer3, 0, wxALIGN_TOP|wxALL, 0); 
    
    m_ListBox = new wxListBox( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, *m_Choices, wxLB_SINGLE );
    m_ListBox->SetSelection(0);
    itemBoxSizer3->Add(m_ListBox, 0, wxALIGN_TOP|wxALL, 5); 

    m_ListBox2 = new wxListBox( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, *m_Choices, wxLB_SINGLE );
    m_ListBox2->SetSelection(0);
    itemBoxSizer3->Add(m_ListBox2, 0, wxALIGN_TOP|wxALL, 5);

    m_CheckBox = new wxCheckBox (itemPanel1, wxID_ANY, _("Leave on original"));
    itemBoxSizer2->Add(m_CheckBox, 0, wxALIGN_LEFT|wxALL, 5);
}


void CConvertSubpanel::ApplyToAll(int col) 
{ 
    int col2 = GetColumn2();
    if (col2 < 0 ) return;

    if (col == col2) return;

    bool first = true;
    objects::edit::EExistingText method = objects::edit::eExistingText_replace_old;
    for (int i = 0; i < this->m_Grid->GetNumberRows(); i++)
        if (!this->m_Grid->IsReadOnly(i,col) && !this->m_Grid->IsReadOnly(i,col2) && this->m_Grid->IsRowShown(i))
        {
            string value =  this->m_Grid->GetCellValue(i,col).ToStdString();
            string existing_value =  this->m_Grid->GetCellValue(i,col2).ToStdString();
            if (first && !existing_value.empty())
            {
                method = GetExistingTextHandling(m_Grid->GetColLabelValue(col2).ToStdString());
                first = false;
            }
            if (method != objects::edit::eExistingText_cancel)
            {
                AddValueToString(existing_value,value,method);  
                ChangeValue(existing_value, i, col2);             
                if (!m_CheckBox->GetValue())
                {
                    ChangeValue(kEmptyStr,i,col);
                }
            }
        }
}

void CConvertSubpanel::ApplyToSelected(int col, const std::set<int> &selected) 
{
    int col2 = GetColumn2();
    if (col2 < 0 ) return;
    if (col == col2) return;
    bool first = true;
    objects::edit::EExistingText method = objects::edit::eExistingText_replace_old;
    for (std::set<int>::const_iterator i = selected.begin(); i != selected.end(); ++i)
        if (!this->m_Grid->IsReadOnly(*i,col) && !this->m_Grid->IsReadOnly(*i,col2) && this->m_Grid->IsRowShown(*i))
        {
            string value =  this->m_Grid->GetCellValue(*i,col).ToStdString();
            string existing_value =  this->m_Grid->GetCellValue(*i,col2).ToStdString();
            if (first && !existing_value.empty())
            {
                method = GetExistingTextHandling(m_Grid->GetColLabelValue(col2).ToStdString());
                first = false;
            }
            if (method != objects::edit::eExistingText_cancel)
            {
                AddValueToString(existing_value,value,method);  
                ChangeValue(existing_value, *i, col2);             
                this->m_Grid->SetCellTextColour(*i,col2,wxColour(255, 160, 0));
                this->m_Grid->SetCellValue(*i,col2,wxString(existing_value));    
                if (!m_CheckBox->GetValue())
                {
                    ChangeValue(kEmptyStr,*i,col);
                }
            }
        }

}



/*
 * CParseSubpanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CParseSubpanel, CSubpanel )

BEGIN_EVENT_TABLE( CParseSubpanel, CSubpanel )

END_EVENT_TABLE()

void CParseSubpanel::CreateControls()
{    
    CParseSubpanel* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemPanel1->SetSizer(itemBoxSizer2);

    wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(itemBoxSizer3, 0, wxALIGN_TOP|wxALL, 0); 

    m_ListBox = new wxListBox( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, *m_Choices, wxLB_SINGLE );
    m_ListBox->SetSelection(0);
    itemBoxSizer3->Add(m_ListBox, 0, wxALIGN_TOP|wxALL, 5);

    m_ListBox2 = new wxListBox( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, *m_Choices, wxLB_SINGLE );
    m_ListBox2->SetSelection(0);
    itemBoxSizer3->Add(m_ListBox2, 0,  wxALIGN_TOP|wxALL, 5);

    m_ParseOptions = new CParseTextOptionsDlg( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxSIMPLE_BORDER );
    itemBoxSizer2->Add(m_ParseOptions, 0,  wxALIGN_LEFT|wxALL, 5);

}

void CParseSubpanel::ApplyToAll(int col) 
{ 
    int col2 = GetColumn2();
    if (col2 < 0 ) return;
    if (col == col2) return;
    CRef<objects::edit::CParseTextOptions> parse_options = m_ParseOptions->GetParseOptions();
    bool first = true;
    objects::edit::EExistingText method = objects::edit::eExistingText_replace_old;
    for (int i = 0; i < this->m_Grid->GetNumberRows(); i++)
        if (!this->m_Grid->IsReadOnly(i,col) && !this->m_Grid->IsReadOnly(i,col2) && this->m_Grid->IsRowShown(i))
        {
            string value =  this->m_Grid->GetCellValue(i,col).ToStdString();
            string value2 =  this->m_Grid->GetCellValue(i,col2).ToStdString();
            string new_val = m_ParseOptions->GetSelectedText(value);
            if (new_val.empty() || new_val == value2) continue;
            if (parse_options->ShouldRemoveFromParsed())
                parse_options->RemoveSelectedText(value);

            if (first && !value2.empty())
            {
                method = GetExistingTextHandling(m_Grid->GetColLabelValue(col2).ToStdString());
                first = false;
            }
            if (method != objects::edit::eExistingText_cancel)
            {
                AddValueToString(value2,new_val,method);  
                ChangeValue(value2, i, col2);             
                ChangeValue(value,i,col);
            }
        }
}

void CParseSubpanel::ApplyToSelected(int col, const std::set<int> &selected) 
{
    int col2 = GetColumn2();
    if (col2 < 0 ) return;
    if (col == col2) return;
    CRef<objects::edit::CParseTextOptions> parse_options = m_ParseOptions->GetParseOptions();
    bool first = true;
    objects::edit::EExistingText method = objects::edit::eExistingText_replace_old;
    for (std::set<int>::const_iterator i = selected.begin(); i != selected.end(); ++i)
        if (!this->m_Grid->IsReadOnly(*i,col) && !this->m_Grid->IsReadOnly(*i,col2) && this->m_Grid->IsRowShown(*i))
        {
            string value =  this->m_Grid->GetCellValue(*i,col).ToStdString();
            string value2 =  this->m_Grid->GetCellValue(*i,col2).ToStdString();
            string new_val = m_ParseOptions->GetSelectedText(value);
            if (new_val.empty() || new_val == value2) continue;
            if (parse_options->ShouldRemoveFromParsed())
                parse_options->RemoveSelectedText(value);
            if (first && !value2.empty())
            {
                method = GetExistingTextHandling(m_Grid->GetColLabelValue(col2).ToStdString());
                first = false;
            }
            if (method != objects::edit::eExistingText_cancel)
            {
                AddValueToString(value2,new_val,method);  
                ChangeValue(value2, *i, col2);             
                ChangeValue(value,*i,col);
            }
        }

}


/*
 * CChangeCaseSubpanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CChangeCaseSubpanel, CSubpanel )

BEGIN_EVENT_TABLE( CChangeCaseSubpanel, CSubpanel )

END_EVENT_TABLE()

void CChangeCaseSubpanel::CreateControls()
{    
    CChangeCaseSubpanel* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemPanel1->SetSizer(itemBoxSizer2);
    
    m_ListBox = new wxListBox( itemPanel1, wxID_ANY, wxDefaultPosition, wxDefaultSize, *m_Choices, wxLB_SINGLE );
    m_ListBox->SetSelection(0);
    itemBoxSizer2->Add(m_ListBox, 0, wxALIGN_LEFT|wxALL, 5);

    m_CapChangeOptions = new CCapChangePanel(itemPanel1);
    itemBoxSizer2->Add(m_CapChangeOptions, 0, wxALIGN_LEFT|wxALL, 5);
}


void CChangeCaseSubpanel::ApplyToAll(int col) 
{ 
    for (int i = 0; i < this->m_Grid->GetNumberRows(); i++)
        if (!this->m_Grid->IsReadOnly(i,col)  && this->m_Grid->IsRowShown(i))
        {
            string value =  this->m_Grid->GetCellValue(i,col).ToStdString();
            ECapChange cap_change = m_CapChangeOptions->GetCapitalizationRequest();
            objects::CSeq_entry_Handle seh;
            FixCapitalizationInString(seh, value, cap_change);
            ChangeValue(value,i,col);
        }
}

void CChangeCaseSubpanel::ApplyToSelected(int col, const std::set<int> &selected) 
{
    for (std::set<int>::const_iterator i = selected.begin(); i != selected.end(); ++i)
        if (!this->m_Grid->IsReadOnly(*i,col)  && this->m_Grid->IsRowShown(*i))
        {
            string value =  this->m_Grid->GetCellValue(*i,col).ToStdString();
            ECapChange cap_change = m_CapChangeOptions->GetCapitalizationRequest();
            objects::CSeq_entry_Handle seh;
            FixCapitalizationInString(seh, value, cap_change);
            ChangeValue(value,*i,col);
        }

}

END_NCBI_SCOPE
