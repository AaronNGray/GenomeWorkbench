/*  $Id: subprepfieldeditor.cpp 33301 2015-07-02 16:49:20Z filippov $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data,  the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties,  express or implied,  including
 *  warranties of performance,  merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors:  Colleen Bollin
 */


#include <ncbi_pch.hpp>

////@begin includes
////@end includes

#include <gui/widgets/wx/wx_utils.hpp>
#include <gui/packages/pkg_sequence_edit/subprepfieldeditor.hpp>
#include <gui/packages/pkg_sequence_edit/subprep_util.hpp>
#include <gui/utils/app_popup.hpp>

////@begin XPM images
////@end XPM images

BEGIN_NCBI_SCOPE

/*!
 * CSubPrepFieldEditor type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CSubPrepFieldEditor, wxPanel )


/*!
 * CSubPrepFieldEditor event table definition
 */

BEGIN_EVENT_TABLE( CSubPrepFieldEditor, wxPanel )

////@begin CSubPrepFieldEditor event table entries
////@end CSubPrepFieldEditor event table entries
    EVT_HYPERLINK( ID_EDITCTRL, CSubPrepFieldEditor::OnEditctrlHyperlinkClicked )
    EVT_HYPERLINK( ID_REGISTER_URL, CSubPrepFieldEditor::OnRegisterHyperlinkClicked )
    EVT_CHOICE( ID_GLOBALCHOICE, CSubPrepFieldEditor::OnGlobalchoiceSelected )
    EVT_HYPERLINK( ID_CLEARCTRL, CSubPrepFieldEditor::OnClearValues )

END_EVENT_TABLE()


/*!
 * CSubPrepFieldEditor constructors
 */

CSubPrepFieldEditor::CSubPrepFieldEditor()
{
    Init();
}

CSubPrepFieldEditor::CSubPrepFieldEditor( wxWindow* parent, objects::CSeq_entry_Handle seh, 
                                          ICommandProccessor* processor, 
                                          IWorkbench* workbench,
                                          wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
 : m_Seh(seh) ,
   m_CmdProcessor(processor),
   m_Workbench(workbench)
{
    Init();
    Create(parent, id, pos, size, style);
}


/*!
 * CSubPrepFieldEditor creator
 */

bool CSubPrepFieldEditor::Create( wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CSubPrepFieldEditor creation
    wxPanel::Create( parent, id, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CSubPrepFieldEditor creation
    return true;
}


/*!
 * CSubPrepFieldEditor destructor
 */

CSubPrepFieldEditor::~CSubPrepFieldEditor()
{
////@begin CSubPrepFieldEditor destruction
////@end CSubPrepFieldEditor destruction
}


/*!
 * Member initialisation
 */

void CSubPrepFieldEditor::Init()
{
////@begin CSubPrepFieldEditor member initialisation
    m_Label = NULL;
    m_Star = NULL;
    m_ValueSizer = NULL;
    m_Mix = NULL;
    m_EditSizer = NULL;
////@end CSubPrepFieldEditor member initialisation
    m_Converter = NULL;
    m_Mix = NULL;
    m_GlobalText = NULL;
    m_GlobalValue = NULL;
    m_ColumnName = "";
    m_Url = "";
    m_AllowMix = true;
}


/*!
 * Control creation for CSubPrepFieldEditor
 */

void CSubPrepFieldEditor::CreateControls()
{    
////@begin CSubPrepFieldEditor content construction
    // Generated by DialogBlocks, 10/06/2013 17:52:55 (unregistered)

    CSubPrepFieldEditor* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxHORIZONTAL);
    itemPanel1->SetSizer(itemBoxSizer2);

    m_Label = new wxStaticText( itemPanel1, wxID_STATIC, _("Static text field"), wxDefaultPosition, wxSize(60, 45), wxALIGN_CENTRE );
    m_Label->Wrap(20);
    itemBoxSizer2->Add(m_Label, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_Star = new wxStaticText( itemPanel1, wxID_STATIC, _("*"), wxDefaultPosition, wxSize(5, -1), 0 );
    m_Star->SetForegroundColour(wxColour(255, 0, 0));
    itemBoxSizer2->Add(m_Star, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_ValueSizer = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(m_ValueSizer, 0, wxALIGN_CENTER_VERTICAL|wxALL, 0);

    m_Mix = new wxTextCtrl( itemPanel1, ID_MIX, wxEmptyString, wxDefaultPosition, wxSize(400, 45), wxTE_MULTILINE|wxTE_READONLY );
    m_ValueSizer->Add(m_Mix, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_EditSizer = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer2->Add(m_EditSizer, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_EditSizer->Add(200, 40, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

////@end CSubPrepFieldEditor content construction
}


/*!
 * Should we show tooltips?
 */

bool CSubPrepFieldEditor::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap CSubPrepFieldEditor::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CSubPrepFieldEditor bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CSubPrepFieldEditor bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon CSubPrepFieldEditor::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CSubPrepFieldEditor icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CSubPrepFieldEditor icon retrieval
}


void CSubPrepFieldEditor::x_ShowStar(bool show)
{
    if (show) {
        m_Star->SetLabel(wxT("*"));
    } else {
        m_Star->SetLabel(wxT(" "));
    }
}


// returns true if type was changed (and therefore a new layout is needed)
bool CSubPrepFieldEditor::x_SetEditorType(bool mixed, bool has_choices)
{
    bool rval = false;
    if (mixed) {
        if (m_Mix == NULL) {
            while (m_ValueSizer->GetItemCount() > 0) {
                size_t pos = 0;
                m_ValueSizer->GetItem(pos)->DeleteWindows();
                m_ValueSizer->Remove(pos);
            }
            m_GlobalValue = NULL;
            m_GlobalText = NULL;
            m_Mix = new wxTextCtrl( this, ID_MIX, wxEmptyString, wxDefaultPosition, wxSize(400, -1), wxTE_MULTILINE|wxTE_READONLY );
            m_ValueSizer->Add(m_Mix, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

            rval = true;
        }
    } else if (has_choices) {
        if (m_GlobalValue == NULL) {
            while (m_ValueSizer->GetItemCount() > 0) {
                size_t pos = 0;
                m_ValueSizer->GetItem(pos)->DeleteWindows();
                m_ValueSizer->Remove(pos);
            }
            m_Mix = NULL;
            m_GlobalText = NULL;
            wxArrayString m_GlobalValueStrings;
            m_GlobalValue = new wxChoice( this, ID_GLOBALCHOICE, wxDefaultPosition, wxSize(400, -1), m_GlobalValueStrings, 0 );
            m_ValueSizer->Add(m_GlobalValue, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);
            rval = true;
        }
    } else {
        // add text field
        if (m_GlobalText == NULL) {
            while (m_ValueSizer->GetItemCount() > 0) {
                size_t pos = 0;
                m_ValueSizer->GetItem(pos)->DeleteWindows();
                m_ValueSizer->Remove(pos);
            }
            m_Mix = NULL;
            m_GlobalValue = NULL;
            m_GlobalText = new wxTextCtrl( this, ID_GLOBALTEXT, 
                                              wxEmptyString, wxDefaultPosition, wxSize(400, -1), 
                                              wxTE_MULTILINE);
            m_ValueSizer->Add(m_GlobalText, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5);
            m_GlobalText->Connect(ID_GLOBALTEXT, wxEVT_LEAVE_WINDOW, wxMouseEventHandler(CSubPrepFieldEditor::OnLeaveTextColumnWindow), NULL, this);
            rval = true;
        }
    }  
    return rval;
}


void CSubPrepFieldEditor::x_SetEditorControls(bool mixed, string message)
{
    while (m_EditSizer->GetItemCount() > 0) {
        size_t pos = 0;
        m_EditSizer->GetItem(pos)->DeleteWindows();
        m_EditSizer->Remove(pos);
    }

    // add either Edit or Clear
    if (mixed && !m_AllowMix) {
        wxHyperlinkCtrl* action = new wxHyperlinkCtrl( this, ID_CLEARCTRL, _("Clear"), wxEmptyString, wxDefaultPosition, wxDefaultSize, wxHL_DEFAULT_STYLE );
        m_EditSizer->Add(action, 0, wxALIGN_LEFT|wxALL, 5);
    } else if (m_AllowMix) {
        wxHyperlinkCtrl* action = new wxHyperlinkCtrl( this, ID_EDITCTRL, _("Edit"), wxEmptyString, wxDefaultPosition, wxDefaultSize, wxHL_DEFAULT_STYLE );
        m_EditSizer->Add(action, 0, wxALIGN_LEFT|wxALL, 5);
    }

    // add error message if needed
    if (!NStr::IsBlank(message)) {
        wxStaticText* error = new wxStaticText( this, wxID_STATIC, ToWxString(message), wxDefaultPosition, wxDefaultSize, 0 );
        error->SetForegroundColour(*wxRED);
        m_EditSizer->Add(error, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);
    }

    if (!NStr::IsBlank(m_Url)) {
        string label = ToStdString(m_Label->GetLabel());
        if (NStr::EqualNocase(label, "Sequence Read Archive")) {
            label = "Submit to " + label;
        } else {
            label = "Register new " + label + " accession";
        }
        wxHyperlinkCtrl* url = new wxHyperlinkCtrl( this, ID_REGISTER_URL, 
                                                   ToWxString(label),
                                                   ToWxString(m_Url), wxDefaultPosition, wxDefaultSize, wxHL_DEFAULT_STYLE );
        m_EditSizer->Add(url, 0, wxALIGN_LEFT|wxALL, 5);
    }        
    m_EditSizer->Layout();
}


// return false if field is not needed
bool CSubPrepFieldEditor::UpdateValues(string default_val)
{
    // set editor
    CRef<objects::CSeq_table> table = m_Converter->GetValuesTableFromSeqEntry(m_Seh);
    CRef<objects::CSeqTable_column> col = FindSeqTableColumnByName (table, m_ColumnName);

    bool all_same = AreAllColumnValuesTheSame(col, default_val);
    bool any_missing = AreAnyColumnValuesMissing (col);
    bool must_choose = false;
    if (m_MustChoose) {
        must_choose = !NStr::Equal("Yes", CSubPrep_panel::GetWizardFieldFromSeqEntry(m_Seh, m_ColumnName + " Confirmed"));
    }
    string curr_val = default_val;
    if (must_choose) {
        curr_val = "";
    } else if (all_same && col && col->GetData().GetSize() > 0) {
        curr_val = col->GetData().GetString()[0];
        if (NStr::IsBlank(curr_val)) {
            curr_val = default_val;
        }
    }
    vector<string> expected_values;
    CRef<objects::CSeq_table> options = m_Converter->GetChoices(table);
    if (options && options->IsSetColumns()) {
        objects::CSeq_table::TColumns::const_iterator val_it = table->GetColumns().begin();
        // skip over seqid column
        val_it++;
        objects::CSeq_table::TColumns::const_iterator opt_it = options->GetColumns().begin();
        while (val_it != table->GetColumns().end() && opt_it != options->GetColumns().end()
              && (!(*val_it)->IsSetHeader() 
                  || !(*val_it)->GetHeader().IsSetTitle() 
                  || !MatchColumnName(m_ColumnName, (*val_it)->GetHeader().GetTitle()))) {
            ++val_it;
            ++opt_it;
        }
        if (opt_it != options->GetColumns().end()) {
            for (size_t i = 0; i < (*opt_it)->GetData().GetString().size(); i++) {
                expected_values.push_back((*opt_it)->GetData().GetString()[i]);
            }
        }
    } 
        
    if (!must_choose && all_same && expected_values.size() == 1 && NStr::EqualNocase(curr_val, expected_values[0])) {
        // all values the same, only one value expected and this is it, no need to show the user anything
        return false;
    }

    if (!must_choose && (!m_Required || !any_missing)) {
        x_ShowStar(false);
    } else {
        x_ShowStar(true);
        CSubPrep_panel *parent = x_GetParent();
        if (parent) {
            parent->SetSubmissionNotReady("Must specify " + m_ColumnName);
        }
    }  

    bool has_choices = (expected_values.size() > 0);

    string error_msg = "";

    if (!all_same) {
        x_SetEditorType(true, true);   
        m_Mix->SetValue(ToWxString(m_Converter->CheckForMixedValues(table, m_ColumnName)));
    } else if (has_choices) {
        x_SetEditorType(false, has_choices);
        // build popup to edit all values
        m_GlobalValue->Clear();
        wxArrayString val_strings;
        bool found = false;
        int pos = 0, sel = -1;
        for (vector<string>::iterator s = expected_values.begin(); s != expected_values.end(); ++s, ++pos) {
            val_strings.Add(ToWxString (*s));
            if (NStr::EqualNocase(curr_val, *s)) {
                sel = pos;
                found = true;
            }
        }
        if (!found) {
            val_strings.Add(ToWxString (curr_val));
            sel = pos;
        }

        m_GlobalValue->Append(val_strings);
        m_GlobalValue->SetSelection(sel);

        if (found) {
            // no error message
        } else {
            if (NStr::IsBlank(curr_val)) {
                error_msg = "You must provide a value for " + ToStdString(m_Label->GetLabel()) + ".";
            } else {
                error_msg = ToStdString(m_Label->GetLabel()) + " " + curr_val + " is unexpected.";
            }
        }                
    } else {
        x_SetEditorType(false, has_choices);
        m_GlobalText->SetValue(ToWxString(curr_val));        
    }

    x_SetEditorControls (!all_same, error_msg);
    // update
    Layout();
    Refresh();

    return true;
}


void CSubPrepFieldEditor::SetConverter 
(string label, string col_name, CTableFieldCommandConverter * converter, 
 bool must_choose, bool required, string default_val,
 string url,
 bool allow_mix)
{
    if (m_Converter) {
        //delete m_Converter;
    }
    m_Converter = converter;
    m_ColumnName = col_name;
    m_Url = url;
    m_Required = required;
    m_MustChoose = must_choose;
    m_AllowMix = allow_mix;
    
    // set label    
    m_Label->SetLabel(ToWxString(label));
    if (UpdateValues(default_val)) {
        this->Show(true);
    } else {
        this->Show(false);
    }
}


void CSubPrepFieldEditor::x_SetOneValue(string new_val)
{
    CRef<objects::CSeq_table> table = m_Converter->GetValuesTableFromSeqEntry(m_Seh);
    CRef<objects::CSeqTable_column> col = FindSeqTableColumnByName (table, m_ColumnName);

    if ((!col || !AreAnyColumnValuesPresent(col, "")) && NStr::IsBlank(new_val)) {
        // no change
        return;
    }
    bool any_change = false;
    if (!col) {
        col = new objects::CSeqTable_column();
        col->SetHeader().SetTitle(m_ColumnName);
        for (int row = 0; row < table->GetNum_rows(); row++) {
            col->SetData().SetString().push_back (new_val);
        }
        table->SetColumns().push_back(col);
        any_change = true;
    } else {
        for (int row = 0; row < table->GetNum_rows(); row++) {                
            string val = col->GetData().GetString()[row];
            if (!NStr::EqualNocase (val, new_val)) {
                col->SetData().SetString()[row] = new_val;
                any_change = true;
            }
        }
    }
    if (any_change) {
        // execute command
        CRef<CCmdComposite> cmd = m_Converter->GetCommandFromValuesTable(table, m_Seh);
        if (cmd) {
            if (m_MustChoose) {
                cmd->AddCommand(*CSubPrep_panel::SetWizardFieldInSeqEntry(m_Seh, m_ColumnName + " Confirmed", "Yes"));
            }     
            m_CmdProcessor->Execute(cmd);
        }
    } else {
        // maybe we didn't make a change, but the choice has now been made
        string val = CSubPrep_panel::GetWizardFieldFromSeqEntry(m_Seh, m_ColumnName + " Confirmed");
        if (!NStr::EqualNocase(val, "Yes")) {
            CRef<CCmdComposite> cmd = CSubPrep_panel::SetWizardFieldInSeqEntry(m_Seh, m_ColumnName + " Confirmed", "Yes");
            m_CmdProcessor->Execute(cmd);
        }
    }        
}


/*!
 * wxEVT_COMMAND_CHOICE_SELECTED event handler for ID_GLOBALCHOICE
 */

void CSubPrepFieldEditor::OnGlobalchoiceSelected( wxCommandEvent& event )
{
    string new_val = ToStdString(event.GetString());
    x_SetOneValue(new_val);
}


CSubPrep_panel* CSubPrepFieldEditor::x_GetParent()
{
    wxWindow* w = this->GetParent();
    while (w != NULL) {
        CSubPrep_panel* parent = dynamic_cast<CSubPrep_panel*>(w);
        if (parent) {
            return parent;
        } else {
            w = w->GetParent();
        }
    }
    return NULL;
}


/*!
 * wxEVT_COMMAND_HYPERLINK event handler for ID_EDITCTRL
 */

void CSubPrepFieldEditor::OnEditctrlHyperlinkClicked( wxHyperlinkEvent& event )
{
    CSubPrep_panel *parent = x_GetParent();
    if (!parent) {
        return;
    }    

    CTableCommandConverter* converter = parent->GetConverterForFieldName(ToStdString(m_Label->GetLabel()));
    CTblEditDlg *dlg = new CTblEditDlg(NULL, m_Seh, converter, m_Workbench, SYMBOL_CTBLEDITDLG_IDNAME, m_Label->GetLabel());
    parent->HandleBulkCmdDlg(dlg);
}


/*!
 * wxEVT_COMMAND_HYPERLINK event handler for ID_EDITCTRL
 */

void CSubPrepFieldEditor::OnClearValues( wxHyperlinkEvent& event )
{
    CSubPrep_panel *parent = x_GetParent();
    if (!parent) {
        return;
    }  

    CRef<CCmdComposite> cmd = m_Converter->ClearAllValues(m_Seh);
    m_CmdProcessor->Execute(cmd);
}


void CSubPrepFieldEditor::OnLeaveTextColumnWindow(wxMouseEvent &event)
{
    if (m_GlobalText == NULL) {
        return;
    }

    string new_val = ToStdString(m_GlobalText->GetValue());

    x_SetOneValue(new_val);
}


/*!
 * wxEVT_COMMAND_HYPERLINK event handler for ID_REGISTER_URL
 */

void CSubPrepFieldEditor::OnRegisterHyperlinkClicked( wxHyperlinkEvent& event )
{
    if (!NStr::IsBlank(m_Url)) {
        CAppPopup::PopupURL(m_Url);
        //event.Skip();
    }
}


END_NCBI_SCOPE


