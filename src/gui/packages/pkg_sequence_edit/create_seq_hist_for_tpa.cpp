/*  $Id: create_seq_hist_for_tpa.cpp 38984 2017-07-14 19:48:54Z filippov $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data,  the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties,  express or implied,  including
 *  warranties of performance,  merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors:  Igor Filippov
 */

#include <ncbi_pch.hpp>

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes
#include <objects/general/User_object.hpp>
#include <objects/general/User_field.hpp>
#include <objects/general/Object_id.hpp>
#include <objects/general/general_macros.hpp>
#include <objects/seq/Seq_hist.hpp>
#include <objects/seq/Seq_hist.hpp>
#include <objects/seqalign/Dense_seg.hpp>
#include <objmgr/scope.hpp>
#include <objmgr/bioseq_handle.hpp>
#include <objmgr/seqdesc_ci.hpp>
#include <objmgr/bioseq_ci.hpp>
#include <sra/data_loaders/wgs/wgsloader.hpp>
#include <gui/objutils/cmd_change_bioseq_inst.hpp>


#include <algo/blast/api/sseqloc.hpp>
#include <algo/blast/api/bl2seq.hpp>
#include <algo/blast/api/blast_nucl_options.hpp>
#include <algo/blast/api/blast_types.hpp>

#include <gui/widgets/edit/generic_report_dlg.hpp>  
#include <gui/packages/pkg_sequence_edit/create_seq_hist_for_tpa.hpp>

////@begin XPM images
////@end XPM images

BEGIN_NCBI_SCOPE
USING_SCOPE(objects);

/*
 * CCreateSeqHistForTpa type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CCreateSeqHistForTpa, wxDialog )


/*
 * CCreateSeqHistForTpa event table definition
 */

BEGIN_EVENT_TABLE( CCreateSeqHistForTpa, wxDialog )

////@begin CCreateSeqHistForTpa event table entries
////@end CCreateSeqHistForTpa event table entries

END_EVENT_TABLE()


/*
 * CCreateSeqHistForTpa constructors
 */

CCreateSeqHistForTpa::CCreateSeqHistForTpa()
{
    Init();
}

CCreateSeqHistForTpa::CCreateSeqHistForTpa( wxWindow* parent, CSeq_entry_Handle seh, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
    : m_TopSeqEntry(seh)
{
    Init();
    Create(parent, id, caption, pos, size, style);
}


/*
 * CCreateSeqHistForTpa creator
 */

bool CCreateSeqHistForTpa::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CCreateSeqHistForTpa creation
    SetExtraStyle(wxWS_EX_BLOCK_EVENTS);
    wxDialog::Create( parent, id, caption, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CCreateSeqHistForTpa creation
    return true;
}


/*
 * CCreateSeqHistForTpa destructor
 */

CCreateSeqHistForTpa::~CCreateSeqHistForTpa()
{
////@begin CCreateSeqHistForTpa destruction
////@end CCreateSeqHistForTpa destruction
}


/*
 * Member initialisation
 */

void CCreateSeqHistForTpa::Init()
{
////@begin CCreateSeqHistForTpa member initialisation
    m_WordSize = NULL;
    m_ExpectValue = NULL;
    m_AllowRepeats = NULL;
////@end CCreateSeqHistForTpa member initialisation  
}


/*
 * Control creation for CCreateSeqHistForTpa
 */

void CCreateSeqHistForTpa::CreateControls()
{    
////@begin CCreateSeqHistForTpa content construction
    // Generated by DialogBlocks, 07/01/2016 08:41:24 (unregistered)

    CCreateSeqHistForTpa* itemDialog1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemDialog1->SetSizer(itemBoxSizer2);

    wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(itemBoxSizer3, 0, wxALIGN_LEFT|wxALL, 5);

    wxStaticText* itemStaticText4 = new wxStaticText( itemDialog1, wxID_STATIC, _("Word Size"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer3->Add(itemStaticText4, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_WordSize = new wxTextCtrl( itemDialog1, wxID_ANY, _("28"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer3->Add(m_WordSize, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer6 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(itemBoxSizer6, 0, wxALIGN_LEFT|wxALL, 5);

    wxStaticText* itemStaticText7 = new wxStaticText( itemDialog1, wxID_STATIC, _("Expect Value"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer6->Add(itemStaticText7, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_ExpectValue = new wxTextCtrl( itemDialog1, wxID_ANY, _("0.000001"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer6->Add(m_ExpectValue, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    // TODO
    //m_AllowRepeats = new wxCheckBox( itemDialog1, wxID_ANY, _("Allow Repeats"), wxDefaultPosition, wxDefaultSize, 0 );
    //m_AllowRepeats->SetValue(false);
    //itemBoxSizer2->Add(m_AllowRepeats, 0, wxALIGN_LEFT|wxALL, 5);

    wxBoxSizer* itemBoxSizer10 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(itemBoxSizer10, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton11 = new wxButton( itemDialog1, wxID_OK, _("Accept"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer10->Add(itemButton11, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton12 = new wxButton( itemDialog1, wxID_CANCEL, _("Cancel"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer10->Add(itemButton12, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

////@end CCreateSeqHistForTpa content construction
}


/*
 * Should we show tooltips?
 */

bool CCreateSeqHistForTpa::ShowToolTips()
{
    return true;
}

/*
 * Get bitmap resources
 */

wxBitmap CCreateSeqHistForTpa::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CCreateSeqHistForTpa bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CCreateSeqHistForTpa bitmap retrieval
}

/*
 * Get icon resources
 */

wxIcon CCreateSeqHistForTpa::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CCreateSeqHistForTpa icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CCreateSeqHistForTpa icon retrieval
}

CRef<CCmdComposite> CCreateSeqHistForTpa::GetCommand()
{
    string msg;

    double word_size;
    if(!m_WordSize->GetValue().ToDouble(&word_size))
    { 
        return CRef<CCmdComposite>(NULL);        
    }
    double expect_value;
    if(!m_ExpectValue->GetValue().ToDouble(&expect_value))
    { 
        return CRef<CCmdComposite>(NULL);        
    }

    CRef<CCmdComposite> cmd = GetCreateSeqHistFromTpaCommand(m_TopSeqEntry, msg, word_size, expect_value);

    if (!msg.empty())
    {
        CGenericReportDlg* report = new CGenericReportDlg(GetParent()); 
        report->SetTitle(wxT("TPA Alignment Assembly Problems"));
        report->SetText(wxString(msg));
        report->Show(true);
    }
    return cmd;
}

CRef<CCmdComposite> CCreateSeqHistForTpa::GetCreateSeqHistFromTpaCommand(CSeq_entry_Handle tse, string &msg, double word_size, double expect_value)
{
    CRef<CCmdComposite> cmd(new CCmdComposite("Create Seq-hist for TPA"));

    if (!tse)
        return cmd;
    
    CScope &scope = tse.GetScope();
    scope.AddDataLoader(CWGSDataLoader::GetLoaderNameFromArgs());

    bool no_tpa_descriptors = true;
    for (CBioseq_CI bi(tse); bi; ++bi)
    {
        bool found = false;
        CBioseq_Handle bsh = *bi;
        string label;
        bsh.GetSeqId()->GetLabel(&label, CSeq_id::eContent);
        string unable_msg, non_nuc_msg;
        vector<CRef<objects::CSeq_align> > align_vector;
        for ( CSeqdesc_CI userobj_iter(bsh, CSeqdesc::e_User, 1); userobj_iter; ++userobj_iter) 
        {
            const CUser_object& user = userobj_iter->GetUser();
            if (user.IsSetType() && user.GetType().IsStr() && user.GetType().GetStr() == "TpaAssembly") // User-object.type.str 
            {
                found = true;
                no_tpa_descriptors = false;
                if (bsh.IsNucleotide())
                {
                    FOR_EACH_USERFIELD_ON_USEROBJECT(field, user)
                    {
                        if ((*field)->IsSetData() && (*field)->GetData().IsFields())
                        {
                            string accession;
                            int from = 0; 
                            int to = 0;
                            for ( CUser_field::C_Data::TFields::const_iterator subfield = (*field)->GetData().GetFields().begin(); subfield != (*field)->GetData().GetFields().end(); ++subfield)
                            {
                                if ((*subfield)->IsSetLabel() && (*subfield)->GetLabel().IsStr() && (*subfield)->GetLabel().GetStr() == "accession" &&
                                    (*subfield)->IsSetData() && (*subfield)->GetData().IsStr())
                                    accession = (*subfield)->GetData().GetStr();
                                if ((*subfield)->IsSetLabel() && (*subfield)->GetLabel().IsStr() && (*subfield)->GetLabel().GetStr() == "from" &&
                                    (*subfield)->IsSetData() && (*subfield)->GetData().IsInt())
                                    from = (*subfield)->GetData().GetInt();
                                if ((*subfield)->IsSetLabel() && (*subfield)->GetLabel().IsStr() && (*subfield)->GetLabel().GetStr() == "to" &&
                                    (*subfield)->IsSetData() && (*subfield)->GetData().IsInt())
                                    to = (*subfield)->GetData().GetInt();
                            }
                            if (!accession.empty())
                            {
                                CSeq_id acc_id(accession, CSeq_id::fParse_Default);
                                CBioseq_Handle bsh2;
                                try
                                {
                                    bsh2 = scope.GetBioseqHandle(acc_id);
                                }
                                catch(CException &e) {} catch (exception &e) {}  
                               
                                if (bsh2)
                                {
                                    if (bsh2.IsNucleotide())
                                    {
                                        size_t old_size = align_vector.size();
                                        try
                                        {
                                            RunBlast(bsh, bsh2, align_vector, from, to, word_size, expect_value);
                                        }
                                        catch(CException &e) {} catch (exception &e) {}  
                                       
                                        size_t new_size = align_vector.size();
                                        if (old_size == new_size)
                                            msg += "Accession " + accession + " does not align to the bioseq " + label + "\n";
                                    }
                                    else
                                        non_nuc_msg += accession + " is not a nucleotide bioseq.\n";
                                }
                                else
                                    unable_msg += "Unable to load " + accession + "\n";
                            }
                        }
                    }
                }
            }
        }
        if (!found)
            continue;
        if (!bsh.IsNucleotide())
        {
            msg += label + " is annotated on a non-nucleotide bioseq.\n";
            continue;
        }
       
        CRef<CSeq_inst> new_inst(new CSeq_inst);
        new_inst->Assign(bsh.GetBioseqCore()->GetInst());
        CSeq_hist &hist = new_inst->SetHist();
        hist.ResetAssembly();
        for (size_t i = 0; i < align_vector.size(); i++)
        {
            CRef< CSeq_align > align(new CSeq_align);
            align->Assign(*align_vector[i]);
            align->SetSegs().SetDenseg().TrimEndGaps();
            align->SetSegs().SetDenseg().RemovePureGapSegs();
            align->SetSegs().SetDenseg().Compact();
            hist.SetAssembly().push_back(align);
        }

        string validation_errors = ValidateAlignments(hist, bsh);
        if (validation_errors.empty())
        {
            cmd->AddCommand(*CRef<CCmdChangeBioseqInst>(new CCmdChangeBioseqInst(bsh, *new_inst)));
            msg += "Alignments were successfully created and are being added to " + label + "\n";
        }
        else if (!align_vector.empty())
        {
            cmd->AddCommand(*CRef<CCmdChangeBioseqInst>(new CCmdChangeBioseqInst(bsh, *new_inst)));
            msg += "Alignments were created but are not valid. They are being added to " + label + " for review.\n";
        }
        else
            msg += "No alignments could be created for " + label + "\n";        

        msg += unable_msg;
        msg += non_nuc_msg;
        msg += validation_errors;
    }
    if (no_tpa_descriptors)
        msg =  "No Tpa features found in SeqEntry.";

    return cmd;
}

void CCreateSeqHistForTpa::RunBlast(const CBioseq_Handle& sh, const CBioseq_Handle& qh, vector<CRef<objects::CSeq_align> > &align_vector, int from, int to, double word_size, double expect_value)
{
    CRef<CSeq_loc> query_seqloc = qh.GetRangeSeq_loc(0, 0);
    CRef<CSeq_loc> subject_seqloc = sh.GetRangeSeq_loc(from, to); 
    if (query_seqloc.IsNull() || subject_seqloc.IsNull()) {
        return;
    }
    
    CScope &scope = sh.GetScope();
    blast::SSeqLoc query_sl(*query_seqloc, scope);
    blast::SSeqLoc subject_sl(*subject_seqloc, scope);
    blast::CBl2Seq bl2seq(subject_sl, query_sl, blast::eMegablast);
    blast::CBlastNucleotideOptionsHandle& opts = dynamic_cast<blast::CBlastNucleotideOptionsHandle&>(bl2seq.SetOptionsHandle());
    opts.SetTraditionalMegablastDefaults();
    opts.SetWordSize(word_size);
    opts.SetEvalueThreshold(expect_value);   
    opts.SetFilterString("F");
    opts.SetMismatchPenalty(-3); // to correspond to sequin default options, c++ defaults to -2.
    //opts.SetGapOpeningCost(-1); // default in c++ is 0, c++ crashes when set to -1
    //opts.SetGapExtensionCost(-1); // default in c++ is 0, c++ crashes when set to -1
    //opts.GetOptions().DebugDumpText(cout, "BLAST Options", 0);

    vector< CRef<objects::CSeq_align_set> > res = bl2seq.Run();
    CRef<CSeq_align_set> align =  res.front();

    if (align && align->IsSet() && !align->Get().empty()) 
        align_vector.push_back(align->Get().front());
}

string CCreateSeqHistForTpa::ValidateAlignments(const CSeq_hist &hist, const CBioseq_Handle &bsh)
{
    string errors;
    string label;
    bsh.GetSeqId()->GetLabel(&label, CSeq_id::eContent);
    if (!hist.IsSetAssembly() || hist.GetAssembly().empty())
    {
        errors = "Consensus sequence " + label + " has no assembly\n";
        return errors;
    }
    TSeqPos length = bsh.GetBioseqLength();
    vector<bool> coverage(length, false);
    for ( CSeq_hist::TAssembly::const_iterator align = hist.GetAssembly().begin(); align != hist.GetAssembly().end(); ++align)
    {
        int num_rows = (*align)->CheckNumRows();
        if (num_rows != 2)
            continue;
        int start1 = 0;
        int stop1 = 0;
        int start2 = 0;
        int stop2 = 0;
        string accession;
        int row = 0;
        if ((*align)->GetSeq_id(0).Match(*bsh.GetSeqId()))
        {
            start1 = (*align)->GetSeqStart(0);
            stop1 = (*align)->GetSeqStop(0);
            start2 = (*align)->GetSeqStart(1);
            stop2 = (*align)->GetSeqStop(1);
            (*align)->GetSeq_id(1).GetLabel(&accession, CSeq_id::eContent);
        }
        else if ((*align)->GetSeq_id(1).Match(*bsh.GetSeqId()))
        {
            start2 = (*align)->GetSeqStart(0);
            stop2 = (*align)->GetSeqStop(0);
            start1 = (*align)->GetSeqStart(1);
            stop1 = (*align)->GetSeqStop(1);
            (*align)->GetSeq_id(0).GetLabel(&accession, CSeq_id::eContent);
            row = 1;
        }
        else
            continue;

        int assem_len = 0;
        int prim_len = 0;
        if (stop1 > start1)
            assem_len = stop1 - start1 + 1;
        else
            assem_len = start1 - stop1 + 1;
        if (stop2 > start2)
            prim_len = stop2 - start2 + 1;
        else
            prim_len = start2 - stop2 + 1;
        
        if (abs(assem_len - prim_len) >= .1 * assem_len || abs(assem_len - prim_len) >= .1 * prim_len ||
            abs(assem_len - prim_len) > 50)
        {
            errors += "Too many gaps in alignment between " + label + " and " + accession + "\n";
        }

        if (!(*align)->IsSetSegs() || !(*align)->GetSegs().IsDenseg() ||
            !(*align)->GetSegs().GetDenseg().IsSetStarts() || !(*align)->GetSegs().GetDenseg().IsSetLens())
            continue;

        vector< TSignedSeqPos > starts((*align)->GetSegs().GetDenseg().GetStarts()); 
        vector< TSeqPos > lens((*align)->GetSegs().GetDenseg().GetLens());
        size_t num_segs = lens.size();    

        for (size_t seg = 0; seg < num_segs; ++seg)
        {
            TSignedSeqPos seg_start = starts[num_rows*seg+row];
            if (seg_start < 0)
                continue;
            TSeqPos len = lens[seg];
            for (size_t i = seg_start; i < seg_start + len; i++)
                coverage[i] = true;
        }
    }

    int zero_start = -1;
    for (int tmp = 0; tmp < length; tmp++) 
    {
      if (!coverage[tmp]) 
      {
          if (zero_start == -1) 
          {
              zero_start = tmp;
          }
      } 
      else if (zero_start > -1) 
      {
          int diff = tmp - (zero_start + 1) + 1;
          if (diff > 50) 
          {
              errors += label + ": Large gap in coverage (>50) from " + NStr::IntToString(zero_start + 1) + " to " + NStr::IntToString(tmp) + "\n";
          } 
          else if (diff < 10) 
          {
              errors += label + ": Small gap in coverage (<10) from " + NStr::IntToString(zero_start + 1) + " to " + NStr::IntToString(tmp) + "\n";
          } 
          else 
          {
              errors += label + ": Medium gap in coverage (10-50) from " + NStr::IntToString(zero_start + 1) + " to " + NStr::IntToString(tmp) + "\n";
          }

        zero_start = -1;
      }
    }
    if (!coverage[length - 1]) 
    {
        int diff = length - (zero_start + 1) + 1;
        if (diff > 50) 
        {
            errors += label + ": Large gap in coverage (>50) from " + NStr::IntToString(zero_start + 1) + " to " + NStr::IntToString(length) + "\n";
        } 
        else if (diff < 10) 
        {
            errors += label + ": Small gap in coverage (<10) from " + NStr::IntToString(zero_start + 1) + " to " + NStr::IntToString(length) + "\n";
        } 
        else 
        {
            errors += label + ": Medium gap in coverage (10-50) from " + NStr::IntToString(zero_start + 1) + " to " + NStr::IntToString(length) + "\n";
        }
    }
    return errors;
}

CRef<CCmdComposite> CRemoveSeqHistAssembly::GetCommand(CSeq_entry_Handle tse)
{
    CRef<CCmdComposite> cmd(new CCmdComposite("Remove Seq-hist Assembly"));

    if (!tse)
        return  CRef<CCmdComposite>(NULL);
    
    CScope &scope = tse.GetScope();

    for (CBioseq_CI bi(tse); bi; ++bi)
    {
        CBioseq_Handle bsh = *bi;
        if (bsh.GetBioseqCore()->IsSetInst())
        {
            CRef<CSeq_inst> new_inst(new CSeq_inst);
            new_inst->Assign(bsh.GetBioseqCore()->GetInst());
            if (new_inst->IsSetHist() && new_inst->GetHist().IsSetAssembly())
            {
                new_inst->SetHist().ResetAssembly();
                if (!new_inst->GetHist().IsSetReplaces() && !new_inst->GetHist().IsSetReplaced_by() && !new_inst->GetHist().IsSetDeleted())
                {
                    new_inst->ResetHist();
                }
                cmd->AddCommand(*CRef<CCmdChangeBioseqInst>(new CCmdChangeBioseqInst(bsh, *new_inst)));
            }
        }
    }
    return cmd;
}

END_NCBI_SCOPE
