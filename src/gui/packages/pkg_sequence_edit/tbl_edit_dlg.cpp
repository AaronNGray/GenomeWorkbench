/*  $Id: tbl_edit_dlg.cpp 42186 2019-01-09 19:34:50Z asztalos $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data,  the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties,  express or implied,  including
 *  warranties of performance,  merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors:  Colleen Bollin
 */


#include <ncbi_pch.hpp>

////@begin includes
////@end includes

#include <objects/general/Object_id.hpp>
#include <objects/general/User_field.hpp>
#include <objects/seq/Seqdesc.hpp>
#include <objects/seqfeat/Seq_feat.hpp>
#include <objects/seqfeat/SeqFeatData.hpp>
#include <objmgr/bioseq_ci.hpp>
#include <objmgr/seqdesc_ci.hpp>
#include <gui/packages/pkg_sequence_edit/tbl_edit_dlg.hpp>
#include <gui/packages/pkg_sequence_edit/molinfoedit_util.hpp>
//#include <gui/packages/pkg_sequence_edit/srcedit_util.hpp>
#include <gui/widgets/edit/field_type_constants.hpp>
#include <gui/packages/pkg_sequence_edit/subprep_util.hpp>
#include <gui/objutils/cmd_create_desc.hpp>
#include <gui/objutils/descriptor_change.hpp>
#include <gui/objutils/cmd_del_desc.hpp>

#include <gui/widgets/loaders/open_objects_dlg.hpp>
#include <gui/widgets/loaders/file_load_wizard.hpp>
#include <gui/utils/object_loader.hpp>
#include <gui/utils/execute_unit.hpp>
#include <gui/widgets/wx/async_call.hpp>

#include <wx/msgdlg.h>
#include <wx/stattext.h>

////@begin XPM images
////@end XPM images

BEGIN_NCBI_SCOPE

USING_SCOPE(ncbi::objects);


/*!
 * CTblEditDlg type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CTblEditDlg, CBulkCmdDlg )


/*!
 * CTblEditDlg event table definition
 */

BEGIN_EVENT_TABLE( CTblEditDlg, CBulkCmdDlg )

////@begin CTblEditDlg event table entries
    EVT_BUTTON( ID_IMPORT_TABLE, CTblEditDlg::OnImportTableClick )

    EVT_BUTTON( ID_EXPORT_TABLE, CTblEditDlg::OnExportTableClick )

    EVT_BUTTON( ID_CLEAR_TABLE, CTblEditDlg::OnClearTableClick )

////@end CTblEditDlg event table entries

    EVT_BUTTON( ID_UPDATE_PROBLEMS, CTblEditDlg::OnUpdateProblems )

END_EVENT_TABLE()


/*!
 * CTblEditDlg constructors
 */

CTblEditDlg::CTblEditDlg()
: m_Converter (NULL)
{
    Init();
}

CTblEditDlg::CTblEditDlg( wxWindow* parent, CSeq_entry_Handle seh, 
                          CTableCommandConverter* converter,
                          IWorkbench* workbench,
                          wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style, wxString label )
: m_TopSeqEntry(seh),
  m_Converter (converter),
  m_Workbench (workbench),
  m_StaticLabel(label)
{
    Init();
    Create(parent, id, caption, pos, size, style);
}


/*!
 * CTblEditDlg creator
 */

bool CTblEditDlg::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CTblEditDlg creation
    SetExtraStyle(wxWS_EX_BLOCK_EVENTS);
    CBulkCmdDlg::Create( parent, id, caption, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CTblEditDlg creation
    return true;
}


/*!
 * CTblEditDlg destructor
 */

CTblEditDlg::~CTblEditDlg()
{
////@begin CTblEditDlg destruction
////@end CTblEditDlg destruction
    delete m_Converter;
}


/*!
 * Member initialisation
 */

void CTblEditDlg::Init()
{
////@begin CTblEditDlg member initialisation
    m_GridHolder = NULL;
    m_TableControlsSizer = NULL;
    m_ImportBtn = NULL;
    m_ExportBtn = NULL;
////@end CTblEditDlg member initialisation
    m_SaveFileDir = wxEmptyString;
    m_SaveFileName = wxEmptyString;
}


/*!
 * Control creation for CTblEditDlg
 */

void CTblEditDlg::CreateControls()
{    
////@begin CTblEditDlg content construction
    // Generated by DialogBlocks, 10/06/2013 17:54:01 (unregistered)

    CTblEditDlg* itemCBulkCmdDlg1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemCBulkCmdDlg1->SetSizer(itemBoxSizer2);

    m_GridHolder = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer2->Add(m_GridHolder, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    m_TableControlsSizer = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(m_TableControlsSizer, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    m_ImportBtn = new wxButton( itemCBulkCmdDlg1, ID_IMPORT_TABLE, _("Import Table"), wxDefaultPosition, wxDefaultSize, 0 );
    m_TableControlsSizer->Add(m_ImportBtn, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    m_ExportBtn = new wxButton( itemCBulkCmdDlg1, ID_EXPORT_TABLE, _("Export Table"), wxDefaultPosition, wxDefaultSize, 0 );
    m_TableControlsSizer->Add(m_ExportBtn, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton7 = new wxButton( itemCBulkCmdDlg1, ID_CLEAR_TABLE, _("Clear Table"), wxDefaultPosition, wxDefaultSize, 0 );
    m_TableControlsSizer->Add(itemButton7, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxBoxSizer* itemBoxSizer8 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(itemBoxSizer8, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton9 = new wxButton( itemCBulkCmdDlg1, wxID_OK, _("Accept"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer8->Add(itemButton9, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton10 = new wxButton( itemCBulkCmdDlg1, wxID_CANCEL, _("Cancel"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer8->Add(itemButton10, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

////@end CTblEditDlg content construction
    if (!m_StaticLabel.empty())
    {
        wxStaticText* staticPrompt = new wxStaticText(itemCBulkCmdDlg1, wxID_STATIC, m_StaticLabel, wxDefaultPosition, wxDefaultSize, wxALIGN_CENTER);
        m_GridHolder->Add(staticPrompt,0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);
    }

    CRef<CSeq_table> values_table = m_Converter->GetValuesTableFromSeqEntry(m_TopSeqEntry);
    CRef<CSeq_table> choices = m_Converter->GetChoices(values_table);
    int glyph_col =   m_Converter->GetCollapsible();
    m_Grid = new CSeqTableGridPanel(this, values_table, choices, glyph_col);
    m_GridHolder->Add(m_Grid, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    m_Grid->UpdateColumnLabelHeight();
    m_Grid->SetBestTableWidth();

    CFeatureTableCommandConverter* converter = dynamic_cast<CFeatureTableCommandConverter *>(m_Converter);
    if (converter) {
        wxButton* problem_btn = new wxButton( itemCBulkCmdDlg1, ID_UPDATE_PROBLEMS, _("Recheck Problems"), wxDefaultPosition, wxDefaultSize, 0 );
        m_TableControlsSizer->Add(problem_btn, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);
    }

    // set read-only columns
    int pos = 0;
    bool all_read_only = true;
    ITERATE (CSeq_table::TColumns, it, values_table->GetColumns()) {
        if (pos > 0) {
            if ((*it)->IsSetHeader() && (*it)->GetHeader().IsSetTitle() && m_Converter->IsReadOnlyColumn((*it)->GetHeader().GetTitle())) {
                m_Grid->MakeColumnReadOnly(pos - 1, true);
            } else {
                all_read_only = false;
            }
        }
        pos++;
    }
    if (all_read_only) {
        itemButton7->Show(false);
    }        

    if (!m_Workbench) {
        m_ImportBtn->Show(false);
        m_ExportBtn->Show(false);
    }
}


/*!
 * Should we show tooltips?
 */

bool CTblEditDlg::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap CTblEditDlg::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CTblEditDlg bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CTblEditDlg bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon CTblEditDlg::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CTblEditDlg icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CTblEditDlg icon retrieval
}

CRef<CCmdComposite> CTblEditDlg::GetCommand()
{
    CRef<CSeq_table> values_table = m_Grid->GetValuesTable();
    CRef<CCmdComposite> cmd = m_Converter->GetCommandFromValuesTable(values_table, m_TopSeqEntry);

    return cmd;
}


string CTblEditDlg::GetErrorMessage()
{
    CRef<CSeq_table> values_table = m_Grid->GetValuesTable();
    return m_Converter->GetErrorMessage(values_table);
}


static int s_FindColumn( CRef<CSeq_table> table, const string& name )
{
    int i = 0;

    for (i = 0; i < table->GetColumns().size(); i++) {
        CConstRef<CSeqTable_column> col = table->GetColumns()[i];
        if (col->IsSetHeader()) {
            if(col->GetHeader().IsSetTitle() && NStr::Equal(col->GetHeader().GetTitle(), name)) {
                return i;
            }
            if (col->GetHeader().IsSetField_name() && NStr::Equal(col->GetHeader().GetField_name(), name)) {
                return i;
            }
        }
    }
    return -1;
}


static void x_SetAllTableStringValues ( CRef<CSeq_table> table, const string& val)
{
    if (!table || !table->IsSetColumns()) {
        return;
    }
    int i = 0;

    for (i = 0; i < table->SetColumns().size(); i++) {
        CRef<CSeqTable_column> col = table->SetColumns()[i];
        if (col->IsSetData() && col->GetData().IsString()) {
            for (int j = 0; j < col->GetData().GetString().size(); j++) {
                col->SetData().SetString()[j] = val;
            }
        }
    }
}


// Converters

string CTableCommandConverter::CheckForMixedValues(CRef<objects::CSeq_table> values_table, string column_name)
{
    CRef<objects::CSeqTable_column> comment_col = FindSeqTableColumnByName (values_table, column_name);
    bool all_same = AreAllColumnValuesTheSame (comment_col, "");

    string msg = "";
    if (!all_same) {
        msg = column_name + " differs for different sequences.";
    }
    return msg;
}


// Converter for DBLink Fields
CRef<objects::CSeq_table> CDBLinkTableCommandConverter::GetValuesTableFromSeqEntry(CSeq_entry_Handle seh)
{
    CRef<CSeq_table> values_table = BuildDBLinkValuesTableFromSeqEntry(seh);
    ITERATE (vector<string>, it, m_DBLinkFields) {
        if (s_FindColumn(values_table, *it) < 0) {
            // add the column
            AddValueToTable(values_table, *it, "", values_table->GetNum_rows() - 1);
        }
    }
    FillShortColumns(values_table);

    return values_table;
}


CRef<CCmdComposite> CDBLinkTableCommandConverter::GetCommandFromValuesTable(CRef<CSeq_table>values_table, CSeq_entry_Handle seh)
{
    return ApplyDBLinkValuesTableToSeqEntry(values_table, seh);
}


CRef<CCmdComposite> CDBLinkTableCommandConverter::ClearAllValues(objects::CSeq_entry_Handle seh)
{
    CRef<CCmdComposite> cmd( new CCmdComposite("Bulk DBLink Descriptor Remove") );
    
    objects::CBioseq_CI b_iter(seh, objects::CSeq_inst::eMol_na);
    for ( ; b_iter ; ++b_iter ) {    
        objects::CSeqdesc_CI desc_ci( *b_iter, objects::CSeqdesc::e_User);
        while (desc_ci) {
            if (desc_ci->GetUser().IsSetType() 
                && desc_ci->GetUser().GetType().IsStr()
                && NStr::EqualNocase(desc_ci->GetUser().GetType().GetStr(), "DBLink")) {
                CIRef<IEditCommand> cmdDelDesc(new CCmdDelDesc(desc_ci.GetSeq_entry_Handle(), *desc_ci));
                cmd->AddCommand(*cmdDelDesc);
            }
            ++desc_ci;
        }
    }
    return cmd;
}


string CDBLinkTableCommandConverter::RemapColumnName(string column_name)
{
    ITERATE (vector<string>, it, m_DBLinkFields) {
        if (NStr::EqualNocase(*it, column_name)) {
            return *it;
        }
    }
    return "";
}


string CDBLinkTableCommandConverter::GetErrorMessage(CRef<CSeq_table>)
{
    return "Unknown error";
}


// Converter for comment descriptors
CRef<objects::CSeq_table> CCommentDescriptorTableCommandConverter::GetValuesTableFromSeqEntry(CSeq_entry_Handle seh)
{
    CRef<CSeq_table> values_table = BuildCommentDescriptorValuesTableFromSeqEntry(seh, m_Label);
    FillShortColumns(values_table);

    return values_table;
}


CRef<CCmdComposite> CCommentDescriptorTableCommandConverter::GetCommandFromValuesTable(CRef<CSeq_table>values_table, CSeq_entry_Handle seh)
{
    return ApplyCommentValuesTableToSeqEntry(values_table, seh, m_Label);
}


CRef<CCmdComposite> CCommentDescriptorTableCommandConverter::ClearAllValues(objects::CSeq_entry_Handle seh)
{
    CRef<CCmdComposite> cmd( new CCmdComposite("Bulk Comment Descriptor Remove") );
    
    objects::CBioseq_CI b_iter(seh, objects::CSeq_inst::eMol_na);
    for ( ; b_iter ; ++b_iter ) {    
        objects::CSeqdesc_CI desc_ci( *b_iter, objects::CSeqdesc::e_Comment);
        while (desc_ci) {
            CIRef<IEditCommand> cmdDelDesc(new CCmdDelDesc(desc_ci.GetSeq_entry_Handle(), *desc_ci));
            cmd->AddCommand(*cmdDelDesc);
            ++desc_ci;
        }
    }
    return cmd;
}


string CCommentDescriptorTableCommandConverter::RemapColumnName(string column_name)
{
    return m_Label;
}


string CCommentDescriptorTableCommandConverter::GetErrorMessage(CRef<CSeq_table>)
{
    return "Unknown error";
}


string CCommentDescriptorTableCommandConverter::CheckForMixedValues(CRef<objects::CSeq_table> values_table, string column_name)
{
    CRef<objects::CSeqTable_column> comment_col = FindSeqTableColumnByName (values_table, m_Label);
    bool all_same = AreAllColumnValuesTheSame (comment_col, "");

    if (all_same) {
        return "";
    } else {
        return m_Label + " differs for different sequences.  This is unexpected.";
    }
}


// Converter for chimera comment descriptors
CRef<objects::CSeq_table> CChimeraCommentDescriptorTableCommandConverter::GetValuesTableFromSeqEntry(CSeq_entry_Handle seh)
{
    CRef<CSeq_table> values_table = BuildChimeraValuesTableFromSeqEntry(seh, m_Label, m_SrcType);
    FillShortColumns(values_table);

    return values_table;
}


CRef<CCmdComposite> CChimeraCommentDescriptorTableCommandConverter::GetCommandFromValuesTable(CRef<CSeq_table>values_table, CSeq_entry_Handle seh)
{
    return ApplyChimeraValuesTableToSeqEntry(values_table, seh, m_Label);
}


CRef<CCmdComposite> CChimeraCommentDescriptorTableCommandConverter::ClearAllValues(objects::CSeq_entry_Handle seh)
{
    CRef<CSeq_table> values_table = GetValuesTableFromSeqEntry (seh);
    x_SetAllTableStringValues(values_table, "");
    return ApplySrcTableToSeqEntry(values_table, seh);
}


string CChimeraCommentDescriptorTableCommandConverter::RemapColumnName(string column_name)
{
    return m_Label;
}


string CChimeraCommentDescriptorTableCommandConverter::GetErrorMessage(CRef<CSeq_table>)
{
    return "Unknown error";
}


string CChimeraCommentDescriptorTableCommandConverter::CheckForMixedValues(CRef<objects::CSeq_table> values_table, string column_name)
{
    CRef<objects::CSeqTable_column> comment_col = FindSeqTableColumnByName (values_table, m_Label);
    bool all_same = AreAllColumnValuesTheSame (comment_col, "");
    bool any_missing = AreAnyColumnValuesMissing (comment_col);
    if (all_same) {
        return "";
    } else if (any_missing) {
        return "Chimera program information is not provided for all sequences";
    } else {
        return "Chimera program information is provided but is not consistent for all sequences";
    }
}


// Converter for Molinfo fields
CRef<objects::CSeq_table> CMolInfoTableCommandConverter::GetValuesTableFromSeqEntry(CSeq_entry_Handle seh)
{
    CRef<CSeq_table> values_table = BuildMolInfoValuesTableFromSeqEntry(seh, m_WizardType);
    FillShortColumns(values_table);

    return values_table;
}


CRef<CCmdComposite> CMolInfoTableCommandConverter::GetCommandFromValuesTable(CRef<CSeq_table> values_table, CSeq_entry_Handle seh)
{
    return ApplyMolInfoValuesTableToSeqEntry(values_table, seh);
}


CRef<CCmdComposite> CMolInfoTableCommandConverter::GetCommandFromValuesTable(CRef<CSeq_table> values_table, CSeq_entry_Handle seh, bool add_confirmed)
{
    return ApplyMolInfoValuesTableToSeqEntry(values_table, seh, add_confirmed);
}


CRef<CCmdComposite> CMolInfoTableCommandConverter::ClearAllValues(objects::CSeq_entry_Handle seh)
{
    CRef<CSeq_table> values_table = GetValuesTableFromSeqEntry (seh);
    x_SetAllTableStringValues(values_table, "");
    return ApplySrcTableToSeqEntry(values_table, seh);
}


CRef<CSeqTable_column> s_GetNthColumn(CRef<CSeq_table> table, int n) 
{
    while (table->GetColumns().size() <= n) {
        CRef<CSeqTable_column> col(new CSeqTable_column());
        table->SetColumns().push_back(col);
    }
    return table->SetColumns()[n];
}


CRef<objects::CSeq_table> CMolInfoTableCommandConverter::GetChoices(CRef<CSeq_table> values_table)
{
    CRef<CSeq_table> choices(new CSeq_table());
    // TODO: Add existing values as choices
    int mol_pos = s_FindColumn( values_table, kMoleculeType );
    int top_pos = s_FindColumn( values_table, kTopology );

    if (mol_pos > 0) {
        CRef<CSeqTable_column> col = s_GetNthColumn(choices, mol_pos - 1);
        vector<string> mol_strings = GetMoleculeTypeOptions (m_WizardType);
        for (size_t i = 0; i < mol_strings.size(); i++) {
            col->SetData().SetString().push_back(mol_strings[i]);
        }
    }
    if (top_pos > 0) {
        CRef<CSeqTable_column> col = s_GetNthColumn(choices, top_pos - 1);
        col->SetData().SetString().push_back("linear");
        if (m_WizardType != CSourceRequirements::eWizardType_d_loop && m_WizardType != CSourceRequirements::eWizardType_microsatellite) {
            col->SetData().SetString().push_back("circular");
        }
    }
    return choices;
}


string CMolInfoTableCommandConverter::RemapColumnName(string column_name)
{
    if (NStr::EqualNocase(column_name, kMoleculeType)
        || NStr::EqualNocase(column_name, "Molecule-Type")
        || NStr::EqualNocase(column_name, "moltype")
        || NStr::EqualNocase(column_name, "mol-type")
        || NStr::EqualNocase(column_name, "mol type")) {
        return kMoleculeType;
    } else if (NStr::EqualNocase(column_name, kTopology)) {
        return kTopology;
    } else {
        return "";
    }
}


string CMolInfoTableCommandConverter::GetErrorMessage(CRef<CSeq_table>)
{
    return "Unknown error";
}


// Converter for src.genome fields
CRef<objects::CSeq_table> CGenomeTableCommandConverter::GetValuesTableFromSeqEntry(CSeq_entry_Handle seh)
{
    vector<string> qual_names;
    qual_names.push_back("genome");
    CRef<CSeq_table> values_table = GetSeqTableForSrcQualFromSeqEntry (seh, qual_names);
    FillShortColumns(values_table);

    return values_table;
}


CRef<CCmdComposite> CGenomeTableCommandConverter::GetCommandFromValuesTable(CRef<CSeq_table> values_table, CSeq_entry_Handle seh)
{
    return ApplySrcTableToSeqEntry(values_table, seh);
}


CRef<CCmdComposite> CGenomeTableCommandConverter::ClearAllValues(objects::CSeq_entry_Handle seh)
{
    CRef<CSeq_table> values_table = GetValuesTableFromSeqEntry (seh);
    x_SetAllTableStringValues(values_table, "");
    return ApplySrcTableToSeqEntry(values_table, seh);
}



string CGenomeTableCommandConverter::RemapColumnName(string column_name)
{
    return "genome";
}


CRef<objects::CSeq_table> CGenomeTableCommandConverter::GetChoices(CRef<CSeq_table> values_table)
{
    CRef<CSeq_table> choices(new CSeq_table());
    CRef<CSeqTable_column> col = s_GetNthColumn(choices, 0);
    vector<string> strings = GetSrcGenomeOptions (m_WizardType, m_SrcType);
    for (size_t i = 0; i < strings.size(); i++) {
        col->SetData().SetString().push_back(strings[i]);
    }
    return choices;
}


string CGenomeTableCommandConverter::GetErrorMessage(CRef<CSeq_table>)
{
    return "Unknown error";
}


string CGenomeTableCommandConverter::CheckForMixedValues(CRef<objects::CSeq_table> values_table, string column_name)
{
    CRef<objects::CSeqTable_column> col = FindSeqTableColumnByName (values_table, column_name);
    bool all_same = AreAllColumnValuesTheSame (col, "");

    if (all_same) {
        return "";
    } else {
        return "Sequences contain a mixture of organelles.  This is unusual.";
    }
}



// converter for primer info
static const string kUniversalPrimers = "[universal primers]";
static const string kSpeciesSpecificPrimers = "[amplified with species-specific primers]";
static const string kUniversalPrimersLabel = "universal primers";
static const string kSpeciesSpecificPrimersLabel = "species-specific primers";
static const string kPrimerType = "Primer Type";

static bool s_RemoveValueFromNote (string& note, string value)
{
    bool any_change = false;
    size_t pos = NStr::Find(note, value);
    if (pos != string::npos) {
        string before = "";
        if (pos > 0) {
            before = note.substr(0, pos);
        }
        string after = note.substr(pos + value.length());
        note = before + after;
        any_change = true;
    }
    return any_change;
}


CRef<objects::CSeq_table> CPrimerTableCommandConverter::GetValuesTableFromSeqEntry(CSeq_entry_Handle seh)
{
    vector<string> qual_names;
    qual_names.push_back(kSubSourceNote);
    qual_names.push_back("fwd-primer-name");
    qual_names.push_back("fwd-primer-seq");
    qual_names.push_back("rev-primer-name");
    qual_names.push_back("rev-primer-seq");
    CRef<CSeq_table> values_table = GetSeqTableForSrcQualFromSeqEntry (seh, qual_names);
    FillShortColumns(values_table);

    CRef<CSeqTable_column> note_col = FindSeqTableColumnByName (values_table, kSubSourceNote);
    note_col->SetHeader().SetTitle(kPrimerType);
    for (int j = 0; j < note_col->GetData().GetString().size(); j++) {
        if (NStr::Find(note_col->GetData().GetString()[j], kUniversalPrimers) != string::npos) {
            note_col->SetData().SetString()[j] = kUniversalPrimersLabel;
        } else if (NStr::Find(note_col->GetData().GetString()[j], kSpeciesSpecificPrimers) != string::npos) {
            note_col->SetData().SetString()[j] = kSpeciesSpecificPrimersLabel;
        } else {
            note_col->SetData().SetString()[j] = "";
        }
    }

    return values_table;
}


CRef<CCmdComposite> CPrimerTableCommandConverter::GetCommandFromValuesTable(CRef<CSeq_table> values_table, CSeq_entry_Handle seh)
{
    vector<string> qual_names;
    qual_names.push_back(kSubSourceNote);
    
    CRef<CSeq_table> orig_notes = GetSeqTableForSrcQualFromSeqEntry (seh, qual_names);
    CRef<CSeqTable_column> orig_note_col = FindSeqTableColumnByName (orig_notes, kSubSourceNote);
    CRef<CSeqTable_column> new_note_col = FindSeqTableColumnByName (values_table, kPrimerType);

    new_note_col->SetHeader().SetTitle(kSubSourceNote);
    for (int j = 0; j < new_note_col->GetData().GetString().size(); j++) {
        string orig_val = "";
        string add_val = "";
        if (j < orig_note_col->GetData().GetString().size()) {
            orig_val = orig_note_col->GetData().GetString()[j];
            add_val = orig_val;
            s_RemoveValueFromNote(add_val, kUniversalPrimers);
            s_RemoveValueFromNote(add_val, kSpeciesSpecificPrimers);
        }
        string new_val = new_note_col->GetData().GetString()[j];
        if (NStr::EqualNocase(new_val, kUniversalPrimersLabel)) {
            new_val = kUniversalPrimers;
        } else if (NStr::EqualNocase(new_val, kSpeciesSpecificPrimersLabel)) {
            new_val = kSpeciesSpecificPrimers;
        }
        new_note_col->SetData().SetString()[j] = new_val + add_val;
    }

    CRef<CCmdComposite> cmd = ApplySrcTableToSeqEntry(values_table, seh);
    return cmd;
}


string CPrimerTableCommandConverter::RemapColumnName(string column_name)
{
    if (NStr::EqualNocase(column_name, kPrimerType)) {
        return kPrimerType;
    } else if (IsFwdPrimerName(column_name)) {
        return "fwd-primer-name";
    } else if (IsRevPrimerName(column_name)) {
        return "rev-primer-name";
    } else if (IsFwdPrimerSeq(column_name)) {
        return "fwd-primer-seq";
    } else if (IsRevPrimerSeq(column_name)) {
        return "rev-primer-seq";
    } else {
        return "";
    }
}


string CPrimerTableCommandConverter::GetErrorMessage(CRef<CSeq_table>)
{
    return "Unknown error";
}


CRef<objects::CSeq_table> CPrimerTableCommandConverter::GetChoices(CRef<CSeq_table> values_table)
{
    CRef<CSeq_table> choices(new CSeq_table());
    CRef<CSeqTable_column> col = s_GetNthColumn(choices, 0);
    col->SetData().SetString().push_back(kUniversalPrimersLabel);
    col->SetData().SetString().push_back(kSpeciesSpecificPrimersLabel);
    
    return choices;
}


string CPrimerTableCommandConverter::GetPrimerTypeColumnName()
{
    return kPrimerType;
}


CRef<CCmdComposite> CPrimerTableCommandConverter::ClearAllValues(objects::CSeq_entry_Handle seh)
{
    CRef<CSeq_table> values_table = GetValuesTableFromSeqEntry (seh);
    x_SetAllTableStringValues(values_table, "");
    return GetCommandFromValuesTable (values_table, seh);
}


string CPrimerTableCommandConverter::CheckForMixedValues(CRef<objects::CSeq_table> values_table, string column_name)
{
    CRef<objects::CSeqTable_column> col = FindSeqTableColumnByName (values_table, column_name);

    bool is_primertype = false;
    if (col == NULL && NStr::EqualNocase(column_name, kSubSourceNote)) {
        is_primertype = true;
        col = FindSeqTableColumnByName (values_table, kPrimerType);
    } else if (NStr::EqualNocase(column_name, kPrimerType)) {
        is_primertype = true;
    }

    if (col == NULL) {
        return "";
    }

    string mixed_msg = "";

    if (is_primertype) {        
        int num_universal = 0;
        int num_species = 0;
        int num_both = 0;
        int num_rows = values_table->GetNum_rows();

        for (size_t i = 0; i < col->GetData().GetSize(); i++) {
            bool has_universal = false;
            if (NStr::Find(col->GetData().GetString()[i], kUniversalPrimersLabel) != string::npos) {
                num_universal++;
                has_universal = true;
            }
            if (NStr::Find(col->GetData().GetString()[i], kSpeciesSpecificPrimersLabel) != string::npos) {
                num_species++;
                if (has_universal) {
                    num_both++;
                }
            }
        }
        if (num_both > 0) {
            mixed_msg = "Some sequences specify both universal and species-specific primers.  This is unwanted.";
        } else if (num_universal > 0 && num_species > 0) {
            if (num_universal + num_species < num_rows) {
                mixed_msg = "Primer type information is missing for some sequences.";
            } else {
                mixed_msg = "Sequences are a mixture of universal and species-specific primers.";
            }
        } else if (num_universal > 0 && num_universal < num_rows) {
            mixed_msg = "Universal primers are specifed for some but not all sequences.  This is unexpected.";
        } else if (num_species > 0 && num_species < num_rows) {
            mixed_msg = "Species-specific primers are specifed for some but not all sequences.  This is unexpected.";
        }
    } else {
        bool all_same = AreAllColumnValuesTheSame (col, "");

        if (!all_same) {
            mixed_msg = column_name + " differs for different sequences.";
        }
    }
    return mixed_msg;
}


// Converter for Structured Comment Fields

static string s_GetPrefixForStructuredComment (const objects::CUser_object& user)
{
    string prefix = "";

    ITERATE (objects::CUser_object::TData, field_it, user.GetData()) {
        if ((*field_it)->IsSetLabel() 
            && (*field_it)->GetLabel().IsStr()
            && NStr::Equal((*field_it)->GetLabel().GetStr(), "StructuredCommentPrefix")
            && (*field_it)->IsSetData()
            && (*field_it)->GetData().IsStr()) {
            prefix = (*field_it)->GetData().GetStr();
            return prefix;
        }
    }
    return prefix;
}


CRef<objects::CSeq_table> CStructuredCommentCommandConverter::GetValuesTableFromSeqEntry(CSeq_entry_Handle seh)
{
    CRef<objects::CSeq_table> table(new objects::CSeq_table());
    CRef<objects::CSeqTable_column> id_col(new objects::CSeqTable_column());
    id_col->SetHeader().SetField_id(objects::CSeqTable_column_info::eField_id_location_id);
    id_col->SetHeader().SetTitle(kSequenceIdColLabel);
    table->SetColumns().push_back(id_col);

    size_t row = 0;
    objects::CBioseq_CI b_iter(seh, objects::CSeq_inst::eMol_na);
    for ( ; b_iter ; ++b_iter ) {
        CRef<objects::CSeq_id> id(new objects::CSeq_id());
        id->Assign (*(b_iter->GetSeqId()));
        id_col->SetData().SetId().push_back(id);

        objects::CSeqdesc_CI it (*b_iter, objects::CSeqdesc::e_User);
        while (it) {
            if (it->GetUser().IsSetType() 
                && it->GetUser().GetType().IsStr()
                && NStr::EqualNocase(it->GetUser().GetType().GetStr(), "StructuredComment")
                && NStr::EqualNocase(s_GetPrefixForStructuredComment(it->GetUser()), m_Prefix)) {
                ITERATE (objects::CUser_object::TData, field_it, it->GetUser().GetData()) {
                    if ((*field_it)->IsSetLabel() 
                        && (*field_it)->GetLabel().IsStr()
                        && !NStr::EqualNocase((*field_it)->GetLabel().GetStr(), "StructuredCommentPrefix")
                        && !NStr::EqualNocase((*field_it)->GetLabel().GetStr(), "StructuredCommentSuffix")
                        && (*field_it)->IsSetData()) {
                        string existing_val = "";
                        if ((*field_it)->GetData().IsStr()) {
                            existing_val = (*field_it)->GetData().GetStr();
                        } else if ((*field_it)->GetData().IsStrs()) { 
                            for (vector<CStringUTF8>::const_iterator str_it = (*field_it)->GetData().GetStrs().begin();
                                 str_it != (*field_it)->GetData().GetStrs().end();
                                 ++str_it) {
                                existing_val += ", " + *str_it;
                            }
                            while (NStr::StartsWith(existing_val, ", ")) {
                                existing_val = existing_val.substr(2);
                            }
                        }
                        AddValueToTable (table, (*field_it)->GetLabel().GetStr(), existing_val, row);
                    }
                }
            }
            ++it;
        }

        row++;
    }            

    table->SetNum_rows(row);
    if (row > 0) {
        ITERATE (vector<string>, it, m_Fields) {
            if (s_FindColumn(table, *it) < 0) {
                // add the column
                AddValueToTable(table, *it, "", table->GetNum_rows() - 1);
            }
        }
    }

    return table;
}


CRef<CCmdComposite> CStructuredCommentCommandConverter::GetCommandFromValuesTable (CRef<objects::CSeq_table>values_table, objects::CSeq_entry_Handle seh)
{
    CRef<CCmdComposite> cmd( new CCmdComposite("Bulk Structured Comment Edit") );

    CRef<objects::CSeqTable_column> id_col = FindSeqTableColumnByName (values_table, kSequenceIdColLabel);
    if (!id_col) {
        return cmd;
    }

    const objects::CSeq_table::TColumns & columns = values_table->GetColumns();
    size_t num_cols = columns.size();

    for (size_t row = 0; row < values_table->GetNum_rows() && row < id_col->GetData().GetSize(); row++) {
        objects::CBioseq_Handle bsh = seh.GetBioseqHandle(*(id_col->GetData().GetId()[row]));
        CRef<objects::CSeqdesc> new_desc( new objects::CSeqdesc );

        objects::CSeqdesc_CI desc_ci( bsh, objects::CSeqdesc::e_User);
        bool found = false;
        while (desc_ci && !found) {
            if (desc_ci->GetUser().IsSetType() 
                && desc_ci->GetUser().GetType().IsStr()
                && NStr::EqualNocase(desc_ci->GetUser().GetType().GetStr(), "StructuredComment")
                && NStr::EqualNocase(s_GetPrefixForStructuredComment(desc_ci->GetUser()), m_Prefix)) {
                found = true;
                new_desc->SetUser().Assign(desc_ci->GetUser());
            } else {
                ++desc_ci;
            }
        }

        bool any_change = false;
        if (!found) {
            any_change = true;
            new_desc->SetUser().SetType().SetStr("StructuredComment");
            objects::CUser_field& field = new_desc->SetUser().SetField("StructuredCommentPrefix");
            field.SetLabel().SetStr("StructuredCommentPrefix");
            field.SetData().SetStr(m_Prefix);
        }

        for (size_t i = 1; i < num_cols; i++) {
            string col_name = values_table->GetColumns()[i]->GetHeader().GetTitle();

            objects::CUser_field& field = new_desc->SetUser().SetField(col_name);
            if (!field.IsSetLabel() || !field.GetLabel().IsStr() || NStr::IsBlank(field.GetLabel().GetStr())) {
                field.SetLabel().SetStr(col_name);
            }
            string new_val = values_table->GetColumns()[i]->GetData().GetString()[row];
            field.SetData().SetStr(new_val);
            any_change = true;
        }

        if (!found) {
            any_change = true;
            objects::CUser_field& field = new_desc->SetUser().SetField("StructuredCommentSuffix");
            string suffix = m_Prefix;
            NStr::ReplaceInPlace(suffix, "-START##", "-END##");
            field.SetLabel().SetStr("StructuredCommentSuffix");
            field.SetData().SetStr(suffix);
        }

        if (any_change) {
            if (desc_ci) {
                CRef<CCmdChangeSeqdesc> ecmd(new CCmdChangeSeqdesc(desc_ci.GetSeq_entry_Handle(), *desc_ci, *new_desc));
                cmd->AddCommand (*ecmd);
            } else {
                new_desc->SetUser().SetType().SetStr("StructuredComment");
                cmd->AddCommand( *CRef<CCmdCreateDesc>(new CCmdCreateDesc(bsh.GetParentEntry(), *new_desc)) );
            }
        }
    }

    // send composite command
    return cmd;
}


CRef<CCmdComposite> CStructuredCommentCommandConverter::ClearAllValues(objects::CSeq_entry_Handle seh)
{
    CRef<CCmdComposite> cmd( new CCmdComposite("Bulk Structured Comment Remove") );
    objects::CBioseq_CI b_iter(seh, objects::CSeq_inst::eMol_na);
    for ( ; b_iter ; ++b_iter ) {    
        objects::CSeqdesc_CI desc_ci( *b_iter, objects::CSeqdesc::e_User);
        while (desc_ci) {
            if (desc_ci->GetUser().IsSetType() 
                && desc_ci->GetUser().GetType().IsStr()
                && NStr::EqualNocase(desc_ci->GetUser().GetType().GetStr(), "StructuredComment")
                && NStr::EqualNocase(s_GetPrefixForStructuredComment(desc_ci->GetUser()), m_Prefix)) {
                CIRef<IEditCommand> cmdDelDesc(new CCmdDelDesc(desc_ci.GetSeq_entry_Handle(), *desc_ci));
                cmd->AddCommand(*cmdDelDesc);
            }
            ++desc_ci;
        }
    }
    return cmd;
}


string CStructuredCommentCommandConverter::RemapColumnName(string column_name)
{
    return column_name;
}


string CStructuredCommentCommandConverter::GetErrorMessage(CRef<CSeq_table> table)
{
    // TODO - complain about missing fields here
    return "Unknown error";
}


CFeatureTableCommandConverter::CFeatureTableCommandConverter
(const objects::CSeq_feat& ftemplate, 
 const TFeatureSeqTableColumnList& reqs, 
 const TFeatureSeqTableColumnList& opts)
{
    m_Template = new objects::CSeq_feat(); 
    m_Template->Assign(ftemplate);
    m_Reqs.assign(reqs.begin(), reqs.end());
    m_Opts.assign(opts.begin(), opts.end());
}


static void AddProblemsToColumn 
(CRef<objects::CSeqTable_column> val_col,
 CRef<CFeatureSeqTableColumnBase> rule_col,
 vector<string>& problems)
{
    vector<string> add_values;
    for (size_t j = 0; j < val_col->GetData().GetSize(); j++) {
        add_values.push_back(val_col->GetData().GetString()[j]);
    }
    vector<string> add_problems = rule_col->IsValid(add_values);
    MergeStringVectors(problems, add_problems);
}


CRef<objects::CSeqTable_column> CFeatureTableCommandConverter::MakeProblemsColumn(CRef<objects::CSeq_table> values_table)
{
    vector<string> problems;

    // the first kSkipColumns columns are not associated with column handlers
    for (size_t i = kSkipColumns; i < values_table->GetColumns().size(); i++) {        
        if (values_table->GetColumns()[i]->IsSetData()
            && (values_table->GetColumns()[i]->GetData().IsString())) {
            CRef<CFeatureSeqTableColumnBase> col = GetColumnRuleForFeatureSeqTable(values_table->GetColumns()[i], m_Reqs, m_Opts);
            if (col) {
                AddProblemsToColumn(values_table->GetColumns()[i], col, problems);
            }
        }
    }
    CRef<objects::CSeqTable_column> problems_col(new objects::CSeqTable_column());
    problems_col->SetHeader().SetTitle(kProblems);
    problems_col->SetData().SetString();
    ITERATE(vector<string>, it, problems) {
        problems_col->SetData().SetString().push_back(*it);
    }
    return problems_col;
}


CRef<objects::CSeq_table> CFeatureTableCommandConverter::GetValuesTableFromSeqEntry(objects::CSeq_entry_Handle seh)
{
    CRef<objects::CSeq_table> table = GetFeaturesFromSeqEntry(seh, *m_Template, m_Reqs);
    int num_rows_to_check = 0;
    if (table->IsSetColumns() && table->GetColumns().size() > 0 && table->GetColumns().front()->IsSetData()) {
        num_rows_to_check = table->GetColumns().front()->GetData().GetId().size();
    }

    // add one for every nucleotide sequence that doesn't have one
    objects::CBioseq_CI bi(seh, objects::CSeq_inst::eMol_na);
    while (bi) {
        bool needed = true;
        
        for (int i = 0; i < num_rows_to_check; i++) {
            ITERATE(objects::CBioseq::TId, id_it, bi->GetCompleteBioseq()->GetId()) {
                if (table->GetColumns()[0]->GetSeq_id(i)->Compare(**id_it) == objects::CSeq_id::e_YES) {
                    needed = false;
                    break;
                }
            }
            if (!needed) {
                break;
            }
        }
        if (needed) {
            CRef<objects::CSeq_feat> f(new objects::CSeq_feat());
            f->Assign(*m_Template);
            CRef<objects::CSeq_id> id(new objects::CSeq_id());
            id->Assign(*(bi->GetSeqId()));
            f->SetLocation().SetInt().SetId().Assign(*id);
            f->SetLocation().SetInt().SetFrom(0);
            f->SetLocation().SetInt().SetTo(bi->GetBioseqLength() - 1);
            AddFeatureToSeqTable (*f, table);
        }
        ++bi;
    }

    ITERATE (TFeatureSeqTableColumnList, it, m_Opts) {
        CRef<objects::CSeqTable_column> col = FindSeqTableColumnByName (table, (*it)->GetLabel());
        if (!col) {
            col.Reset(new objects::CSeqTable_column());
            col->SetHeader().SetTitle((*it)->GetLabel());
            for (size_t i = 0; i < table->GetNum_rows(); i++) {
                col->SetData().SetString().push_back("");
            }
            table->SetColumns().push_back(col);
        }
    }

    AddProblemsColumnToFeatureSeqTable(table, m_Reqs, m_Opts);

    FillShortColumns(table);
    
    return table;
}


CRef<CCmdComposite> CFeatureTableCommandConverter::GetCommandFromValuesTable(CRef<objects::CSeq_table> table, objects::CSeq_entry_Handle seh)
{
    CRef<CCmdComposite> cmd(new CCmdComposite("Edit Features by table"));
    bool do_something = false;
    CRef<CCmdComposite> delcmd = RemoveMatchingFeaturesWithoutLocalIntFeatureIdsFromSeqEntry(seh, *m_Template, m_Reqs);
    if (delcmd) {
        cmd->AddCommand(*delcmd);
        do_something = true;
    }
    CRef<CCmdComposite> addcmd = AddFeatureSeqTableToSeqEntry(table, seh, m_Template->GetData().GetSubtype(), m_Reqs, m_Opts);
    if (addcmd) {
        cmd->AddCommand(*addcmd);
        do_something = true;
    }
    
    if (!do_something) {
        cmd.Reset(NULL);
    }
    return cmd;
}


string CFeatureTableCommandConverter::GetErrorMessage(CRef<objects::CSeq_table>)
{
    // TODO - complain about missing fields here
    return "Unknown error";
}


CRef<CCmdComposite> CFeatureTableCommandConverter::ClearAllValues(objects::CSeq_entry_Handle seh)
{
    CRef<CCmdComposite> cmd( NULL );
    return cmd;
}


string CFeatureTableCommandConverter::RemapColumnName(string column_name)
{
    return column_name;
}


CRef<objects::CSeq_table> CFeatureTableCommandConverter::GetChoices(CRef<objects::CSeq_table> values_table)
{
    int partial_start = s_FindColumn( values_table, kPartialStart);
    int partial_stop = s_FindColumn( values_table, kPartialStop );
     
    CRef<objects::CSeq_table> choices(new objects::CSeq_table());

    vector<string> tf_strings = GetTrueFalseList();
    if (partial_start > 0) {
        CRef<CSeqTable_column> col = s_GetNthColumn(choices, partial_start - 1);
        for (size_t i = 0; i < tf_strings.size(); i++) {
            col->SetData().SetString().push_back(tf_strings[i]);
        }
    }
    if (partial_stop > 0) {
        CRef<CSeqTable_column> col = s_GetNthColumn(choices, partial_stop - 1);
        for (size_t i = 0; i < tf_strings.size(); i++) {
            col->SetData().SetString().push_back(tf_strings[i]);
        }
    }

    return choices;
}


vector<string> GetAssemblyDataFields()
{
    vector<string> fields;

    fields.push_back("Assembly Method");
    fields.push_back("Assembly Name");
    fields.push_back("Sequencing Technology");
    fields.push_back("Coverage");

    return fields;
}


string CTblEditDlg::x_FindBadImportColumns (CRef<objects::CSeq_table> table)
{
    CTableFieldCommandConverter* converter = dynamic_cast<CTableFieldCommandConverter *>(m_Converter);
    if (!converter) {
        return "";
    }
    string error = "";
    int col = 1;
    vector<string> already_seen;

    NON_CONST_ITERATE (objects::CSeq_table::TColumns, cit, table->SetColumns()) {
        if ((*cit)->IsSetData() && !(*cit)->GetData().IsId()) {
            string orig_name = "";
            if ((*cit)->IsSetHeader() 
                && (*cit)->GetHeader().IsSetTitle()) {
                orig_name = (*cit)->GetHeader().GetTitle();
            }
            if (NStr::IsBlank(orig_name)) {
                error += "Column " + NStr::NumericToString(col) + " has no header; ";
            } else {
                string new_name = converter->RemapColumnName(orig_name);
                if (NStr::IsBlank(new_name)) {
                    error += "Column " + NStr::NumericToString(col) + " header '" + orig_name + "' is not recognized; ";
                } else {
                    (*cit)->SetHeader().SetTitle(new_name);
                    int as_col = 1;
                    ITERATE (vector<string>, sit, already_seen) {
                        if (NStr::Equal(new_name, *sit)) {
                            error += "Column " + NStr::NumericToString(col) + " (" 
                                  + orig_name + ") and column " + NStr::NumericToString(as_col) 
                                  + " refer to the same field (" + new_name + "); ";
                        }
                        as_col++;
                    }
                    already_seen.push_back(new_name);
                }
            }
        }
        col++;       
    }

    if (!NStr::IsBlank(error)) {
        error = error.substr(0, error.length() - 2);
    }
    return error;
}


/*!
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_IMPORT_TABLE
 */

void CTblEditDlg::OnImportTableClick( wxCommandEvent& event )
{
    CRef<CFileLoadWizard> fileManager(new CFileLoadWizard());
	vector<string> format_ids;
	format_ids.push_back("file_loader_table");
	fileManager->LoadFormats(format_ids);

	//fileManager->SetServiceLocator(m_Workbench);
    vector<CIRef<IOpenObjectsPanelClient> > loadManagers;
    loadManagers.push_back(CIRef<IOpenObjectsPanelClient>(fileManager.GetPointer()));

    COpenObjectsDlg dlg(NULL);
    dlg.SetSize(710, 480);

    dlg.SetRegistryPath("Dialogs.Edit.OpenTable");
    dlg.SetManagers(loadManagers);

    if (dlg.ShowModal() == wxID_OK) {
        CIRef<IObjectLoader> object_loader(dlg.GetObjectLoader());
        if (!object_loader) {
            wxMessageBox(wxT("Failed to get object loader"), wxT("Error"),
                         wxOK | wxICON_ERROR);
        }
        else {
            IExecuteUnit* execute_unit = dynamic_cast<IExecuteUnit*>(object_loader.GetPointer());
            if (execute_unit) {
                if (!execute_unit->PreExecute())
                    return;

                if (!GUI_AsyncExecUnit(*execute_unit, wxT("Reading file(s)...")))
                    return; // Canceled

                if (!execute_unit->PostExecute())
                    return;
            }
            const IObjectLoader::TObjects& objects = object_loader->GetObjects();
            ITERATE(IObjectLoader::TObjects, obj_it, objects) {
                const CObject& ptr = obj_it->GetObject();
                const objects::CSeq_annot* annot = dynamic_cast<const objects::CSeq_annot*>(&ptr);
                if (annot && annot->IsSeq_table()) {
                    CRef<objects::CSeq_table> input_table (new objects::CSeq_table());
                    input_table->Assign(annot->GetData().GetSeq_table());
                    // adjust for import
                    FixTableAfterImport (input_table);

                    // make sure qual names are all legit
                    string error = x_FindBadImportColumns(input_table);
                    if (!NStr::IsBlank(error)) {
                        wxMessageBox(ToWxString(error), wxT("Error"),
                                         wxOK | wxICON_ERROR, this);
                        return;
                    }

                    // get existing table
                    CRef<objects::CSeq_table> values_table = m_Grid->GetValuesTable();
                    if (!values_table) {
                        return;
                    }

                    error = FindBadRows (input_table, values_table, m_TopSeqEntry);
                    if (!NStr::IsBlank(error)) {
                        wxMessageBox(ToWxString(error), wxT("Error"),
                                         wxOK | wxICON_ERROR, this);
                        return;
                    }

                    if (CountTableColumnConflicts(values_table, *input_table) > 0) {
                        wxMessageBox(wxT("New table conflicts with existing values"), wxT("Error"),
                                         wxOK | wxICON_ERROR, this);
                        return;
                    }

                    // merge input table with existing table
                    int num_new = CombineTables (values_table, *input_table);
                    m_Grid->SetValuesTable(values_table);
                }
            }
        }
    }
}


/*!
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_EXPORT_TABLE
 */

void CTblEditDlg::OnExportTableClick( wxCommandEvent& event )
{
    CRef<objects::CSeq_table> grid_table = m_Grid->GetValuesTable();
    if (!grid_table) {
        return;
    }

    CRef<objects::CSeq_table> values_table(new objects::CSeq_table());
    values_table->Assign(*grid_table);

    SaveTableFile (this, m_SaveFileDir, m_SaveFileName, values_table);
}


/*!
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_CLEAR_TABLE
 */

void CTblEditDlg::OnClearTableClick( wxCommandEvent& event )
{
    CRef<objects::CSeq_table> table = m_Grid->GetValuesTable();
    NON_CONST_ITERATE (objects::CSeq_table::TColumns, cit, table->SetColumns()) {
        if ((*cit)->IsSetData() && !(*cit)->GetData().IsId()) {
            bool read_only = false;
            if ((*cit)->IsSetHeader() 
                && (*cit)->GetHeader().IsSetTitle() 
                && m_Converter->IsReadOnlyColumn((*cit)->GetHeader().GetTitle())) {
                read_only = true;
            }

            if (!read_only) {
                (*cit)->SetData().SetString().clear();
            }
        }
    }
    m_Grid->SetValuesTable(table);
}


/*!
 * wxEVT_COMMAND_BUTTON_CLICKED event handler for ID_UPDATE_PROBLEMS
 */

void CTblEditDlg::OnUpdateProblems( wxCommandEvent& event )
{
    CFeatureTableCommandConverter* converter = dynamic_cast<CFeatureTableCommandConverter *>(m_Converter);
    if (converter) {
        CRef<objects::CSeq_table> table = m_Grid->GetValuesTable();
        RemoveProblemsColumn(table);
        CRef<objects::CSeqTable_column> problems = converter->MakeProblemsColumn(table);
        if (problems) {
            table->SetColumns().push_back(problems);
            FillShortColumns(table);
        }
        m_Grid->SetValuesTable(table);
    }
}


END_NCBI_SCOPE
