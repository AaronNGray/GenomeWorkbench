/*  $Id: far_pointer_seq.cpp 38984 2017-07-14 19:48:54Z filippov $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data,  the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties,  express or implied,  including
 *  warranties of performance,  merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors:  Igor Filippov
 */

#include <ncbi_pch.hpp>

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes
#include <objects/seqalign/Dense_seg.hpp>
#include <objmgr/scope.hpp>
#include <objmgr/bioseq_handle.hpp>
#include <objmgr/align_ci.hpp>
#include <objmgr/bioseq_ci.hpp>
#include <objmgr/seq_vector.hpp>
#include <objmgr/util/sequence.hpp>
#include <gui/objutils/cmd_del_bioseq.hpp>
#include <gui/objutils/cmd_del_bioseq_set.hpp>
#include <gui/objutils/cmd_change_align.hpp>

#include <algo/blast/api/sseqloc.hpp>
#include <algo/blast/api/bl2seq.hpp>
#include <algo/blast/api/blast_nucl_options.hpp>
#include <algo/blast/api/blast_types.hpp>

#include <gui/widgets/edit/generic_report_dlg.hpp>  
#include <gui/packages/pkg_sequence_edit/far_pointer_seq.hpp>

////@begin XPM images
////@end XPM images

BEGIN_NCBI_SCOPE
USING_SCOPE(objects);

/*
 * CFarPointerSeq type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CFarPointerSeq, wxDialog )


/*
 * CFarPointerSeq event table definition
 */

BEGIN_EVENT_TABLE( CFarPointerSeq, wxDialog )

////@begin CFarPointerSeq event table entries
EVT_CHECKLISTBOX(ID_FARPOINTERSEQ_CHECKLISTBOX, CFarPointerSeq::OnCheck)
EVT_BUTTON(ID_FARPOINTERSEQ_EXPORT, CFarPointerSeq::OnExport)
////@end CFarPointerSeq event table entries

END_EVENT_TABLE()


/*
 * CFarPointerSeq constructors
 */

CFarPointerSeq::CFarPointerSeq()
{
    Init();
}

CFarPointerSeq::CFarPointerSeq( wxWindow* parent, CSeq_entry_Handle seh, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
    : m_TopSeqEntry(seh)
{
    Init();
    Create(parent, id, caption, pos, size, style);
}


/*
 * CFarPointerSeq creator
 */

bool CFarPointerSeq::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CFarPointerSeq creation
    SetExtraStyle(wxWS_EX_BLOCK_EVENTS);
    wxDialog::Create( parent, id, caption, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CFarPointerSeq creation
    return true;
}


/*
 * CFarPointerSeq destructor
 */

CFarPointerSeq::~CFarPointerSeq()
{
////@begin CFarPointerSeq destruction
////@end CFarPointerSeq destruction
}


/*
 * Member initialisation
 */

void CFarPointerSeq::Init()
{
////@begin CFarPointerSeq member initialisation
    m_CheckListBox = NULL;
////@end CFarPointerSeq member initialisation  
}


/*
 * Control creation for CFarPointerSeq
 */

void CFarPointerSeq::CreateControls()
{    
////@begin CFarPointerSeq content construction
    // Generated by DialogBlocks, 07/01/2016 08:41:24 (unregistered)

    CFarPointerSeq* itemDialog1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemDialog1->SetSizer(itemBoxSizer2);

    string label_max;
    vector<string> msgs;
    vector<bool> checked;
    wxArrayString choices;
    for (CAlign_CI align_it(m_TopSeqEntry); align_it; ++align_it)
    {
        CSeq_align::TDim num_rows = align_it->CheckNumRows();
        for (size_t row = 0; row < num_rows; row++)
        {
            const CSeq_id&  id = align_it->GetSeq_id(row);
            string label;
            id.GetLabel(&label, CSeq_id::eContent);
            bool check(false);
            bool disable(false);
            string msg = GetMessageForId(id, label, check, disable);
            if (!disable && !msg.empty())
                m_errors[label] = msg;
            checked.push_back(check);
            m_disabled.push_back(disable);           
            m_labels.push_back(label);
            msgs.push_back(msg);
            if (label.size() > label_max.size())
                label_max = label;
        }
    }

    wxGraphicsContext *gc = wxGraphicsContext::Create();
    gc->SetFont(GetFont(), *wxBLACK);
    for (size_t i = 0; i < m_labels.size(); i++)
    {
        string label = m_labels[i];
        AddSpaces(label, label_max, gc);
        choices.Add(wxString(label + msgs[i]));
    }
    delete gc;

    if (choices.IsEmpty())
        NCBI_THROW( CException, eUnknown, "No alignment found" );

    m_CheckListBox = new wxCheckListBox( itemDialog1, ID_FARPOINTERSEQ_CHECKLISTBOX, wxDefaultPosition, wxDefaultSize, choices, wxLB_HSCROLL );
    itemBoxSizer2->Add(m_CheckListBox, 1, wxGROW|wxALL, 5);
    for (size_t i = 0; i < checked.size(); i++)
        if (checked[i])
            m_CheckListBox->Check(i, true);

    wxBoxSizer* itemBoxSizer10 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(itemBoxSizer10, 0, wxALIGN_CENTER_HORIZONTAL|wxALL, 5);

    wxButton* itemButton11 = new wxButton( itemDialog1, wxID_OK, _("Replace Selected Sequences"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer10->Add(itemButton11, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton12 = new wxButton( itemDialog1, wxID_CANCEL, _("Cancel"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer10->Add(itemButton12, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxButton* itemButton13 = new wxButton( itemDialog1, ID_FARPOINTERSEQ_EXPORT, _("Export FarPointer Error Messages"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer10->Add(itemButton13, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

////@end CFarPointerSeq content construction
}

void CFarPointerSeq::AddSpaces(string &str, const string& label_max, wxGraphicsContext *gc)
{
    wxDouble width;
    wxDouble height;
    wxDouble descent;
    wxDouble externalLeading;
    gc->GetTextExtent(wxString(str), &width, &height, &descent, &externalLeading);
    wxDouble space_width;
    gc->GetTextExtent(_(" "), &space_width, &height, &descent, &externalLeading);
    wxDouble max_width;
    gc->GetTextExtent(wxString(label_max), &max_width, &height, &descent, &externalLeading);
    if (max_width >= width)
    {
        int add_spaces = int((max_width - width) / space_width) + 1;
        str += string(add_spaces, ' ');
    }   
}

void CFarPointerSeq::OnCheck(wxCommandEvent& event)
{
    Freeze();
    int i = event.GetInt();
    if (m_disabled[i])
        m_CheckListBox->Check(i, false);
    else
        event.Skip();
    m_CheckListBox->EnsureVisible(i);
    Thaw();
}

void CFarPointerSeq::OnExport(wxCommandEvent& event)
{
    string msg;
    for(map<string,string>::const_iterator i = m_errors.begin(); i != m_errors.end(); ++i)
    {
        msg += i->first + "\t" + i->second + "\n";
    }
    if (msg.empty())
        return;
    CGenericReportDlgModal* report = new CGenericReportDlgModal(GetParent()); 
    report->SetTitle(wxT("FarPointer Errors"));
    report->SetText(wxString(msg));
    report->ShowModal();
}

CRef<CCmdComposite> CFarPointerSeq::GetCommand()
{
    CRef<CCmdComposite> cmd(new CCmdComposite("Far Pointer Sequence"));
    CScope& scope = m_TopSeqEntry.GetScope();
    wxArrayInt 	checked;
    m_CheckListBox->GetCheckedItems(checked);

    for (CAlign_CI align_it(m_TopSeqEntry); align_it; ++align_it)
    {
        if (!align_it->IsSetSegs() || !align_it->GetSegs().IsDenseg() ||
            !align_it->GetSegs().GetDenseg().IsSetIds())
            continue;

        CRef<CSeq_align> new_align(new CSeq_align());
        new_align->Assign(align_it.GetOriginalSeq_align());
        CSeq_align::TDim num_rows = align_it->CheckNumRows();
        bool modified(false);

        for (size_t j = 0; j < checked.GetCount(); j++)
        {
            int i = checked.Item(j);
            string label = m_labels[i];
            CBioseq_Handle bsh1 = m_label_to_bsh1[label];
            CBioseq_Handle bsh2 = m_label_to_bsh2[label];
            int offset = m_offset[bsh1];
            bool flip_strand = m_flip_strand[bsh1];

            for (size_t row = 0; row < num_rows; row++)
            {
                const CSeq_id&  id = align_it->GetSeq_id(row);
                CBioseq_Handle bsh = scope.GetBioseqHandle(id);

                if (bsh1 == bsh)
                {
                    if (flip_strand)
                    {
                        ReverseRow(new_align->SetSegs().SetDenseg(), offset, row, num_rows);
                    }
                    else
                    {
                        new_align->OffsetRow(row, offset);
                    }
                    CRef<CSeq_id> new_id(new CSeq_id);
                    CSeq_id_Handle best_idh = sequence::GetId(bsh2, sequence::eGetId_Best);
                    new_id->Assign(*best_idh.GetSeqId());
                    new_align->SetSegs().SetDenseg().SetIds()[row]->Assign(*new_id);                   
                    modified = true;
                }
            }
        }

        if (modified)
        {
            new_align->SetSegs().SetDenseg().RemovePureGapSegs();
            //new_align->SetSegs().SetDenseg().TrimEndGaps();
            new_align->SetSegs().SetDenseg().Compact();
            CIRef<IEditCommand> chgAlign(  new CCmdChangeAlign( align_it.GetSeq_align_Handle(), *new_align ));
            cmd->AddCommand(*chgAlign);
        }
    }

    for (size_t j = 0; j < checked.GetCount(); j++)
    {
        int i = checked.Item(j);
        string label = m_labels[i];
        CBioseq_Handle bsh1 = m_label_to_bsh1[label];
        
        CBioseq_set_Handle bssh = bsh1.GetParentBioseq_set();
        if (bssh && bssh.IsSetClass() && bssh.GetClass() ==  CBioseq_set::eClass_nuc_prot)
            cmd->AddCommand(*CRef<CCmdDelBioseqSet>(new CCmdDelBioseqSet(bssh)));
        else
            cmd->AddCommand(*CRef<CCmdDelBioseq>(new CCmdDelBioseq(bsh1)));
    }
  
    return cmd;
}

void CFarPointerSeq::ReverseRow(CDense_seg &dense_seg, int offset, size_t row, CSeq_align::TDim num_rows)
{
    //flip strands
    if (!dense_seg.IsSetStrands()) 
    {
        dense_seg.SetStrands().resize(dense_seg.GetStarts().size(), eNa_strand_plus);
    }

    for (size_t i = row; i < dense_seg.GetStrands().size(); i += num_rows)
    {
        switch (dense_seg.GetStrands()[i])
        {
        case eNa_strand_plus:  dense_seg.SetStrands()[i] = eNa_strand_minus; break;
        case eNa_strand_minus: dense_seg.SetStrands()[i] = eNa_strand_plus;  break;
        default:                    break;//do nothing if not + or -
        }
    }
   
    //reverse list o' starts
    size_t j;
    for (size_t i = row, j = 0; i < dense_seg.GetStarts().size() && j < dense_seg.GetLens().size(); i += num_rows, j++)
    {
        if (dense_seg.GetStarts()[i] >= 0)
        {
            dense_seg.SetStarts()[i] = offset - dense_seg.SetStarts()[i] - dense_seg.GetLens()[j] + 1;
        }
    }       
}

/*
 * Should we show tooltips?
 */

bool CFarPointerSeq::ShowToolTips()
{
    return true;
}

/*
 * Get bitmap resources
 */

wxBitmap CFarPointerSeq::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CFarPointerSeq bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CFarPointerSeq bitmap retrieval
}

/*
 * Get icon resources
 */

wxIcon CFarPointerSeq::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CFarPointerSeq icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CFarPointerSeq icon retrieval
}

string CFarPointerSeq::GetMessageForId(const CSeq_id &id, string label, bool &check, bool &disable)
{
    if (!NStr::StartsWith(label, "acc"))
    {
        disable = true;
        return "Not a far pointer";
    }
    string orig_label(label);
    CScope& scope = m_TopSeqEntry.GetScope();
    CBioseq_Handle bsh1 = scope.GetBioseqHandle(id);
    NStr::TrimPrefixInPlace(label, "acc");
    CSeq_id acc_id(label, CSeq_id::fParse_Default);
    CBioseq_Handle bsh2;
    try
    {
        bsh2 = scope.GetBioseqHandle(acc_id);
    }
    catch(CException &e) {} catch (exception &e) {} 
   

    if (!bsh1 || !bsh2)
    {
        disable = true;
        return kEmptyStr;
    }

    m_label_to_bsh1[orig_label] = bsh1;
    m_label_to_bsh2[orig_label] = bsh2;

    CRef<objects::CSeq_align>  align;
    try
    {
        align = RunBlast(bsh2, bsh1);
    }
    catch(CException &e) {} catch (exception &e) {} 
   

    return ValidateAlignment(align, bsh1, bsh2, check);
}

CRef<objects::CSeq_align> CFarPointerSeq::RunBlast(const CBioseq_Handle& sh, const CBioseq_Handle& qh)
{
    CRef<CSeq_loc> query_seqloc = qh.GetRangeSeq_loc(0,0);
    CRef<CSeq_loc> subject_seqloc = sh.GetRangeSeq_loc(0,0); 
    if (query_seqloc.IsNull() || subject_seqloc.IsNull()) 
    {
        return CRef<objects::CSeq_align>(NULL);
    }
    
    CScope &scope = sh.GetScope();
    blast::SSeqLoc query_sl(*query_seqloc, scope);
    blast::SSeqLoc subject_sl(*subject_seqloc, scope);
    blast::CBl2Seq bl2seq(query_sl, subject_sl, blast::eMegablast);
    blast::CBlastNucleotideOptionsHandle& opts = dynamic_cast<blast::CBlastNucleotideOptionsHandle&>(bl2seq.SetOptionsHandle());
    opts.SetTraditionalMegablastDefaults();
//    opts.SetFilterString("m L;R");
    opts.SetMaskAtHash(true);
    opts.SetDustFiltering(true);
    //opts.SetRepeatFiltering(true);
    opts.SetMismatchPenalty(-3); // to correspond to sequin default options, c++ defaults to -2.
    //opts.GetOptions().DebugDumpText(cout, "BLAST Options", 0);

    vector< CRef<objects::CSeq_align_set> > res = bl2seq.Run();
    CRef<CSeq_align_set> align =  res.front();

    if (align && align->IsSet() && !align->Get().empty()) 
        return (align->Get().front());
    return CRef<objects::CSeq_align>(NULL);
}


string CFarPointerSeq::ValidateAlignment(CRef<objects::CSeq_align> align, CBioseq_Handle bsh1, CBioseq_Handle bsh2, bool& check)
{
    if (!align)
        return("No alignment found!");

    string errors;
   
    TSeqPos length = bsh1.GetBioseqLength();

    int num_rows = align->CheckNumRows();
    if (num_rows != 2)
        return errors;

    int start1 = 0;
    int stop1 = 0;
    int start2 = 0;
    int stop2 = 0;
    int row1 = 0;
    int row2 = 1;
    bool flip_strand = (align->GetSeqStrand(0) !=  align->GetSeqStrand(1));
    m_flip_strand[bsh1] = flip_strand;

    if (align->GetSeq_id(0).Match(*bsh1.GetSeqId()))
    {
        start1 = align->GetSeqStart(0);
        stop1 = align->GetSeqStop(0);
        start2 = align->GetSeqStart(1);
        stop2 = align->GetSeqStop(1);
    }
    else if (align->GetSeq_id(1).Match(*bsh1.GetSeqId()))
    {
        start1 = align->GetSeqStart(1);
        stop1 = align->GetSeqStop(1);
        start2 = align->GetSeqStart(0);
        stop2 = align->GetSeqStop(0);
        swap(row1, row2);
    }
    else
        return errors;

    if (!flip_strand)
        m_offset[bsh1] = start2 - start1;
    else
        m_offset[bsh1] = stop2 + start1;
    
    int assem_len = 0;
    if (stop1 > start1)
        assem_len = stop1 - start1 + 1;
    else
        assem_len = start1 - stop1 + 1;
  
    string seq1;
    const objects::CSeqVector seqvec( bsh1, objects::CBioseq_Handle::eCoding_Iupac, objects::eNa_strand_plus);
    seqvec.GetSeqData(0, bsh1.GetBioseqLength(), seq1);
    size_t beg = 0;
    for (size_t i = 0; i < seq1.size(); i++)
    {
        if (seq1[i] == 'N')
            beg++;
        else
            break;
    }
    size_t end = 0;
    for (int i = length - 1; i >= 0; i--)
    {
        if (seq1[i] == 'N')
            end++;
        else
            break;
    }
    size_t nctr = 0;
    for (size_t i = 0; i < seq1.size(); i++)
    {
        if (seq1[i] == 'N')
            nctr++;
    }
    nctr -= beg + end;

   
    if (!align->IsSetSegs() || !align->GetSegs().IsDenseg() ||
        !align->GetSegs().GetDenseg().IsSetStarts() || !align->GetSegs().GetDenseg().IsSetLens())
        return errors;

    string seq2;
    const objects::CSeqVector seqvec2( bsh2, objects::CBioseq_Handle::eCoding_Iupac, objects::eNa_strand_plus);
    seqvec2.GetSeqData(0, bsh2.GetBioseqLength(), seq2);

    vector< TSignedSeqPos > starts(align->GetSegs().GetDenseg().GetStarts()); 
    vector< TSeqPos > lens(align->GetSegs().GetDenseg().GetLens());
    size_t num_segs = lens.size();      
    int gaps = 0;
    int mismatches = 0;
    int n = 0;
    int matches = 0;
    string tmp(seq1);
    for (size_t seg = 0; seg < num_segs; ++seg)
    {
        TSignedSeqPos seg_start1 = starts[num_rows*seg+row1];
        TSignedSeqPos seg_start2 = starts[num_rows*seg+row2];
        TSeqPos len = lens[seg];

        if (seg_start1 < 0 || seg_start2 < 0)
        {
            gaps += len;
            continue;
        }
        for (size_t i = 0; i < len; i++)
        {
            char a = seq1[i + seg_start1];
            char b = seq2[i + seg_start2];
            if (a != b)
            {
                if (a != 'N' && b != 'N')
                    mismatches++;
                else
                    n++;
            }
            else
            {
                matches++;
            }
            tmp[i + seg_start1] = '+';
        }
    }
    int uncovered_n = 0;
    int uncovered_non_n = 0;
    for (size_t i = 0; i < tmp.size(); i++)
    {
        if (tmp[i] == '+')
            continue;
        if (tmp[i] == 'N')
            uncovered_n++;
        else
            uncovered_non_n++;
    }
   
    if (gaps>0 || mismatches>0 || n > 0)
    {
        if (beg > 0 || end > 0)
        {
            errors += "The local sequence has " + NStr::ULongToString(beg + end) + " terminal N" + (beg+end > 1 ? "s. " : ". ");
        }
        if (nctr > 0)
        {
            errors += "The local sequence has " + NStr::ULongToString(nctr) + " internal N" + (nctr > 1 ? "s. " : ". ");
        }
    }

    
    if (!errors.empty() && assem_len == length && gaps == 0 && mismatches == 0)
    {
        errors += "There are no other differences between the local and database sequences.";
        return errors;
    }

    if (assem_len < length)
    {
        errors += "The alignment to the database sequence does not cover all of the local sequence. ";

        if (uncovered_n != 0 && uncovered_non_n == 0)
        {
            errors += "The unaligned sequence consists only of Ns. ";
        }
        if (uncovered_non_n != 0)
        {
            errors += "There are non-N residues in the unaligned sequence. ";
        }
    }

    if (gaps > 0 || mismatches > 0 || n > 0)
    {
        errors += "The alignment to the database sequence has " + NStr::ULongToString(gaps) + " gap" + (gaps != 1 ? "s, " : ", ") 
            + NStr::ULongToString(mismatches) + " mismatch" + (mismatches != 1 ? "es, " : ", ") 
            + "and " + NStr::ULongToString(n) + " N-mismatch" + (mismatches != 1 ? "es. " : ". ");
    }

    if (errors.empty())
    {
        check = true;
    }
    return errors;
}

END_NCBI_SCOPE
