/*  $Id: field_choice_panel.cpp 42723 2019-04-05 18:12:08Z filippov $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data,  the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties,  express or implied,  including
 *  warranties of performance,  merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * Authors:  Colleen Bollin
 */


// Generated by DialogBlocks (unregistered), 12/06/2013 14:35:26

#include <ncbi_pch.hpp>
#include <gui/packages/pkg_sequence_edit/field_choice_panel.hpp>
#include <gui/widgets/edit/source_field_name_panel.hpp>
#include <gui/widgets/edit/rna_field_name_panel.hpp>
#include <gui/widgets/edit/cds_gene_prot_field_name_panel.hpp>
#include <gui/packages/pkg_sequence_edit/misc_field_panel.hpp>
#include <gui/packages/pkg_sequence_edit/gene_field_panel.hpp>
#include <gui/packages/pkg_sequence_edit/protein_field_panel.hpp>
#include <gui/widgets/edit/feature_field_name_panel.hpp>
#include <gui/packages/pkg_sequence_edit/molinfoedit_util.hpp>
#include <gui/widgets/edit/field_type_constants.hpp>
#include <gui/widgets/edit/pub_field_name_panel.hpp>
#include <gui/packages/pkg_sequence_edit/pub_field.hpp>
#include <gui/packages/pkg_sequence_edit/dblink_field.hpp>
#include <gui/packages/pkg_sequence_edit/generalid_panel.hpp>
#include <gui/widgets/edit/struct_comm_field_panel.hpp>
#include <gui/widgets/edit/struct_fieldvalue_panel.hpp>
#include <gui/packages/pkg_sequence_edit/dbxref_name_panel.hpp>

BEGIN_NCBI_SCOPE
USING_SCOPE(ncbi::objects);

/*!
 * CFieldChoicePanel type definition
 */

IMPLEMENT_DYNAMIC_CLASS( CFieldChoicePanel, CFieldNamePanel )

wxDEFINE_EVENT(wxEVT_COMMAND_UPDATE_CONSTRAINT_FIELD, wxCommandEvent);
/*!
 * CFieldChoicePanel event table definition
 */

BEGIN_EVENT_TABLE( CFieldChoicePanel, CFieldNamePanel )

////@begin CFieldChoicePanel event table entries
////@end CFieldChoicePanel event table entries
    EVT_CHOICE( ID_CFIELD_TYPE_CHOICE, CFieldChoicePanel::OnFieldTypeChoiceSelected )

END_EVENT_TABLE()


/*!
 * CFieldChoicePanel constructors
 */

CFieldChoicePanel::CFieldChoicePanel()
{
    Init();
}

CFieldChoicePanel::CFieldChoicePanel( wxWindow* parent, const vector<CFieldNamePanel::EFieldType>& field_types, bool horizontal, bool is_pair, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
    : m_IsPair (is_pair), m_IsHorizontal(horizontal), m_Composed(false), m_FieldTypes(field_types), m_Field1(NULL), m_Field2(NULL)
{
    Init();
    Create(parent, field_types, horizontal, id, pos, size, style);
}


/*!
 * CFieldChoicePanel creator
 */

bool CFieldChoicePanel::Create( wxWindow* parent, const vector<CFieldNamePanel::EFieldType>& field_types, bool horizontal, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
////@begin CFieldChoicePanel creation
    CFieldNamePanel::Create( parent, id, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end CFieldChoicePanel creation
    return true;
}


/*!
 * CFieldChoicePanel destructor
 */

CFieldChoicePanel::~CFieldChoicePanel()
{
////@begin CFieldChoicePanel destruction
////@end CFieldChoicePanel destruction
}


/*!
 * Member initialisation
 */

void CFieldChoicePanel::Init()
{
////@begin CFieldChoicePanel member initialisation
    m_TopFieldTypeSizer = NULL;
    m_SideFieldTypeSizer = NULL;
    m_FieldPicker = NULL;
    m_show_legal_only = false;
////@end CFieldChoicePanel member initialisation
}


/*!
 * Control creation for CFieldChoicePanel
 */

void CFieldChoicePanel::CreateControls()
{    
////@begin CFieldChoicePanel content construction
    CFieldChoicePanel* itemCFieldNamePanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemCFieldNamePanel1->SetSizer(itemBoxSizer2);

    m_TopFieldTypeSizer = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(m_TopFieldTypeSizer, 0, wxALIGN_CENTER_HORIZONTAL|wxLEFT|wxRIGHT, 5);

    wxBoxSizer* itemBoxSizer4 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer2->Add(itemBoxSizer4, 0, wxALIGN_LEFT|wxALL, 5);

    m_SideFieldTypeSizer = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer4->Add(m_SideFieldTypeSizer, 0, wxALIGN_TOP|wxLEFT|wxRIGHT, 5);

    m_FieldPicker = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer4->Add(m_FieldPicker, 0, wxALIGN_TOP|wxLEFT|wxRIGHT, 5);

////@end CFieldChoicePanel content construction
    wxArrayString field_type_strings;
    ITERATE(vector<CFieldNamePanel::EFieldType>, it, m_FieldTypes) {
        field_type_strings.Add(ToWxString(CFieldNamePanel::GetFieldTypeName(*it)));
    }
    m_FieldType = new wxChoice( this, ID_CFIELD_TYPE_CHOICE, wxDefaultPosition, wxDefaultSize, field_type_strings, 0 );
    if (m_IsHorizontal) {
        m_SideFieldTypeSizer->Add(m_FieldType);
    } else {
        m_TopFieldTypeSizer->Add(m_FieldType);
    }
}


/*!
 * Should we show tooltips?
 */

bool CFieldChoicePanel::ShowToolTips()
{
    return true;
}

/*!
 * Get bitmap resources
 */

wxBitmap CFieldChoicePanel::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin CFieldChoicePanel bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end CFieldChoicePanel bitmap retrieval
}

/*!
 * Get icon resources
 */

wxIcon CFieldChoicePanel::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin CFieldChoicePanel icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end CFieldChoicePanel icon retrieval
}

void CFieldChoicePanel::IncludeComposedItems(bool show)
{
    m_Composed = show;
}

void CFieldChoicePanel::OnFieldTypeChoiceSelected( wxCommandEvent& event )
{
    string val = ToStdString(m_FieldType->GetStringSelection());
  
    CFieldNamePanel::EFieldType field_type = CFieldNamePanel::GetFieldTypeFromName(val);
    SetFieldType(field_type, m_IsPair);
    
    wxCommandEvent fieldTypeEvent(wxEVT_COMMAND_UPDATE_CONSTRAINT_FIELD, GetId());
    fieldTypeEvent.SetEventObject(this);
    GetEventHandler()->ProcessEvent(fieldTypeEvent);

    x_UpdateParent();
    event.Skip();
}

bool CFieldChoicePanel::SetFieldType(CFieldNamePanel::EFieldType field_type, bool is_pair)
{
    bool rval = false; 
    while (m_FieldPicker->GetItemCount() > 0) {
        size_t pos = 0;
        m_FieldPicker->GetItem(pos)->DeleteWindows();
        m_FieldPicker->Remove(pos);
    }
    m_Field1 = NULL;
    m_Field2 = NULL;

    if (m_FieldType->SetStringSelection(CFieldNamePanel::GetFieldTypeName(field_type))) {
        m_IsPair = is_pair;

        switch (field_type) {
            case CFieldNamePanel::eFieldType_Source:
                m_Field1 = new CSourceFieldNamePanel(this, m_Composed, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
                m_FieldPicker->Add(m_Field1);
                if (x_IsParentAECRDlg()) {
                    CSourceFieldNamePanel* src_panel = dynamic_cast<CSourceFieldNamePanel*>(m_Field1);
                    src_panel->DoNotShowSubList(true);
                }
                if (m_IsPair) {
                    _ASSERT(!m_Composed);
                    m_Field2 = new CSourceFieldNamePanel(this, m_Composed, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
                    m_FieldPicker->Add(m_Field2);
                    if (x_IsParentAECRDlg()) {
                        CSourceFieldNamePanel* src_panel = dynamic_cast<CSourceFieldNamePanel*>(m_Field2);
                        src_panel->HideSourceType();
                        src_panel->DoNotShowSubList(true);
                    }
                }
                
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_Taxname:
                m_Field1 = new CSourceFieldNamePanel(this, m_Composed, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
                m_FieldPicker->Add(m_Field1);
                if (x_IsParentAECRDlg()) {
                    CSourceFieldNamePanel* src_panel = dynamic_cast<CSourceFieldNamePanel*>(m_Field1);
                    src_panel->DoNotShowSubList(true);
                }
                if (m_IsPair) {
                    _ASSERT(!m_Composed);
                    m_Field2 = new CSourceFieldNamePanel(this, m_Composed, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
                    m_FieldPicker->Add(m_Field2);
                    if (x_IsParentAECRDlg()) {
                        CSourceFieldNamePanel* src_panel = dynamic_cast<CSourceFieldNamePanel*>(m_Field2);
                        src_panel->HideSourceType();
                        src_panel->DoNotShowSubList(true);
                    }
                }
                SetOneFieldName("taxname");
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_Feature:
                m_Field1 = new CFeatureFieldNamePanel(this, NULL, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
                m_FieldPicker->Add(m_Field1);
                if (m_IsPair) {
                    m_Field2 = new CFeatureFieldNamePanel(this, dynamic_cast<CFeatureFieldNamePanel*>(m_Field1), wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
                    m_FieldPicker->Add(m_Field2);
                }
                if (m_Field1) {
                    CFeatureFieldNamePanel* featfield_panel = dynamic_cast<CFeatureFieldNamePanel*>(m_Field1);
                    if (featfield_panel) {
                        featfield_panel->PopulateFeatureListbox();
                    }
                }
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_CDSGeneProt:
                m_Field1 = new CCDSGeneProtFieldNamePanel(this);
                m_FieldPicker->Add(m_Field1);
                m_Field1->SetFieldName("protein name");
                if (m_IsPair) {
                    m_Field2 = new CCDSGeneProtFieldNamePanel(this);
                    m_FieldPicker->Add(m_Field2);
                }
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_RNA:
                m_Field1 = new CRNAFieldNamePanel(this, NULL, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
                m_FieldPicker->Add(m_Field1);
                m_Field1->SetFieldName("product");
                if (m_IsPair) {
                    CRNAFieldNamePanel* field_panel = dynamic_cast<CRNAFieldNamePanel*>(m_Field1);
                    m_Field2 = new CRNAFieldNamePanel(this, dynamic_cast<CRNAFieldNamePanel*>(m_Field1), wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
                    m_FieldPicker->Add(m_Field2);
                }
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_Gene:
                m_Field1 = new CGeneFieldPanel(this);
                m_Field1->SetFieldName("locus");
                m_FieldPicker->Add(m_Field1);
                if (m_IsPair) {
                    m_Field2 = new CGeneFieldPanel(this);
                    m_FieldPicker->Add(m_Field2);
                    m_Field2->SetFieldName("locus");
                }
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_Protein:
                m_Field1 = new CProteinFieldPanel(this);
                m_Field1->SetFieldName("name");
                m_FieldPicker->Add(m_Field1);
                if (m_IsPair) {
                    m_Field2 = new CProteinFieldPanel(this);
                    m_FieldPicker->Add(m_Field2);
                    m_Field2->SetFieldName("name");
                }
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_MolInfo:
                {{
                    CFieldHandlerNamePanel* a = new CFieldHandlerNamePanel(this);
                    a->SetFieldNames(CMolInfoField::GetFieldNames());
                    m_Field1 = a;

                    m_FieldPicker->Add(m_Field1);
                    m_Field1->SetFieldName("molecule");
                    if (m_IsPair) {
                        CFieldHandlerNamePanel* b = new CFieldHandlerNamePanel(this);
                        b->SetFieldNames(CMolInfoField::GetFieldNames());
                        m_Field2 = b;
                        m_FieldPicker->Add(m_Field2);
                    }
                }}
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_Pub:
                {{
                    CFieldHandlerNamePanel* a = new CFieldHandlerNamePanel(this);
                    a->SetFieldNames(CPubField::GetFieldNames());
                    m_Field1 = a;

                    m_FieldPicker->Add(m_Field1);
                    m_Field1->SetFieldName("title");
                    if (m_IsPair) {
                        CFieldHandlerNamePanel* b = new CFieldHandlerNamePanel(this);
                        b->SetFieldNames(CPubField::GetFieldNames());
                        m_Field2 = b;
                        m_FieldPicker->Add(m_Field2);
                    }
                }}
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_StructuredComment:
                {{
//                    if (x_IsParentAECRDlg()) {
                        m_Field1 = new CStructCommentFieldPanel(this);
                        m_FieldPicker->Add(m_Field1);
                        if (m_IsPair) {
                            m_Field2 = new CStructCommentFieldPanel(this);
                            m_FieldPicker->Add(m_Field2);
                        }
//                    } else {
//                        m_Field1 = new CStructFieldValuePanel(this);
//                        m_FieldPicker->Add(m_Field1);
//                    }
                    wxCommandEvent fieldTypeEvent(wxEVT_COMMAND_UPDATE_STRUCTCOMMENT_FIELD);
                    fieldTypeEvent.SetEventObject(this);
                    GetEventHandler()->ProcessEvent(fieldTypeEvent);
                }}
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_DBLink:
                {{
                    CFieldHandlerNamePanel* a = new CFieldHandlerNamePanel(this);
                    a->SetFieldNames(CDBLinkField::GetFieldNames());
                    m_Field1 = a;

                    m_FieldPicker->Add(m_Field1);
                    m_Field1->SetFieldName("title");
                    if (m_IsPair) {
                        CFieldHandlerNamePanel* b = new CFieldHandlerNamePanel(this);
                        b->SetFieldNames(CDBLinkField::GetFieldNames());
                        m_Field2 = b;
                        m_FieldPicker->Add(m_Field2);
                    }
                }}
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_Dbxref:
                m_Field1 = new CDbxrefNamePanel(this);
                m_FieldPicker->Add(m_Field1);
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_Misc: 
                {{
                    CFieldHandlerNamePanel* a = new CFieldHandlerNamePanel(this);
                    a->SetFieldNames(CMiscFieldPanel::GetStrings());
                    m_Field1 = a;
                    m_FieldPicker->Add(m_Field1);
                    m_Field1->SetFieldName(kDefinitionLineLabel);
                    if (m_IsPair) {
                        CFieldHandlerNamePanel* b = new CFieldHandlerNamePanel(this);
                        b->SetFieldNames(CMiscFieldPanel::GetStrings());
                        m_Field2 = b;
                        m_FieldPicker->Add(m_Field2);
                    }               
                }}
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_GeneralId:
                m_Field1 = new CGeneralIDPanel(this);
                m_FieldPicker->Add(m_Field1);
                rval = true;
                break;
            case CFieldNamePanel::eFieldType_FlatFile:
            case CFieldNamePanel::eFieldType_BankITComment:
            case CFieldNamePanel::eFieldType_Comment:
            case CFieldNamePanel::eFieldType_DefLine:
            case CFieldNamePanel::eFieldType_LocalId:
            case CFieldNamePanel::eFieldType_SeqId:
                rval = true;
                break;
            default:
                break;
        }
    }

    if (m_Field1) {
        m_Field1->SetShowLegalOnly(m_show_legal_only);
        m_Field1->Layout();
        m_Field1->Fit();
        m_Field1->Refresh();
    }
    if (m_Field2) {
        m_Field2->SetShowLegalOnly(m_show_legal_only);
        m_Field2->Layout();
        m_Field2->Fit();
        m_Field2->Refresh();
    }

    int min_width = 0;
    int min_height = 0;
    int borders = 5;
    
    m_FieldType->GetSize(&min_width, &min_height);
    min_width += borders;
    min_height += borders;
    
    int this_width, this_height;
    if (m_IsHorizontal) {
        if (m_Field1) {
            m_Field1->GetSize(&this_width, &this_height);
            min_width += this_width + borders;
            this_height += borders;
            if (this_height > min_height) {
                min_height = this_height;
            }
        }
        if (m_Field2) {
            m_Field2->GetSize(&this_width, &this_height);
            min_width += this_width + borders;
            this_height += borders;
            if (this_height > min_height) {
                min_height = this_height;
            }
        }
    } else {
        if (m_Field1) {
            m_Field1->GetSize(&this_width, &this_height);
            min_height += this_height + borders;
            this_width += borders;
            if (this_width > min_width) {
                min_width = this_width;
            }
        }
        if (m_Field2) {
            m_Field2->GetSize(&this_width, &this_height);
            min_width += this_width + borders;
        }
    }

    if (m_IsHorizontal && min_width < 400) {
        min_width = 400;
    } else if (min_width < 380) {
        min_width = 380;
    }
    if (m_IsHorizontal && min_height < 150) {
        min_height = 150;
    } else if (min_height < 185) {
        min_height = 185;
    }

    wxSize min_size(min_width, min_height);
    this->SetMinClientSize(min_size);
    Layout();
    Fit();
    Refresh();

    return rval;
}

void CFieldChoicePanel::SetSubpanelSelection(const string &sel)
{
    if (!m_Field1)
        return;
    CSourceFieldNamePanel *field = dynamic_cast<CSourceFieldNamePanel*>( m_Field1);
    if (!field)
        return;
    field->SetSourceSubpanelSelection(sel);
}

string CFieldChoicePanel::GetField1(const bool subfield)
{
    string val = "";
    if (m_Field1) {
        val = m_Field1->GetFieldName(subfield);
    }
    return val;
}


string CFieldChoicePanel::GetField2(const bool subfield)
{
    string val = "";
    if (m_Field2) {
        val = m_Field2->GetFieldName(subfield);
    }
    return val;
}

bool CFieldChoicePanel::IsOneFieldProteinName( void )
{
    if (GetFieldType() == CFieldNamePanel::eFieldType_CDSGeneProt) {
        if (NStr::EqualNocase(GetField1(), "protein name") || (m_IsPair && NStr::EqualNocase(GetField2(), "protein name"))) {
            return true;
        }
    }
    return false;
}

const vector<CFieldNamePanel::EFieldType> CFieldChoicePanel::GetFieldTypes()
{
    vector<CFieldNamePanel::EFieldType> field_types;
    wxArrayString strings = m_FieldType->GetStrings();
    for (size_t i = 0; i < strings.size(); i++) {
        CFieldNamePanel::EFieldType field_type = GetFieldTypeFromName(ToStdString(strings[i]));
        if (field_type != CFieldNamePanel::eFieldType_Unknown) {
            field_types.push_back(field_type);
        }
    }
    return field_types;
}


CFieldNamePanel::EFieldType CFieldChoicePanel::GetFieldType()
{
    return GetFieldTypeFromName(ToStdString(m_FieldType->GetStringSelection()));
}


vector<string> CFieldChoicePanel::GetChoices(bool& allow_other)
{
    vector<string> choices;
    if (m_Field1) {
        choices = m_Field1->GetChoices(allow_other);
    }
    return choices;
}


string CFieldChoicePanel::GetFieldName(const bool subfield)
{
    string field = GetField1();
    if (NStr::IsBlank(field)) {
        field = ToStdString(m_FieldType->GetStringSelection());
        if (!NStr::EqualNocase(field, kFieldTypeSeqId) &&
            !NStr::EqualNocase(field, kLocalId) &&
            !NStr::EqualNocase(field, kFileSeqId) &&
            !NStr::EqualNocase(field, kTaxnameAfterBinomial) &&
            !NStr::EqualNocase(field, kDefinitionLineLabel) &&
            !NStr::EqualNocase(field, kBankITComment) &&
            !NStr::EqualNocase(field, kComment) &&
            !NStr::EqualNocase(field, kFlatFile)) {
            field = kEmptyStr;
        }
    } else {
        string field_type = ToStdString(m_FieldType->GetStringSelection());
        if (NStr::StartsWith(field_type, "RNA") && NStr::Find(field, "RNA") == string::npos && !subfield) {
            field = "RNA " + field;
        }
    }
    return field;
}

bool CFieldChoicePanel::SetOneFieldName(const string& field)
{
    bool rval = false;
    if (m_Field1) {
        rval = m_Field1->SetFieldName(field);
    }
    return rval;
}


bool CFieldChoicePanel::SetFieldName(const string& field)
{
    bool rval = false;

    size_t pos = NStr::Find(field, " ");
    if (pos == string::npos) {
        if (m_Field1) {
            rval = m_Field1->SetFieldName(field);
        }
    } else {
        CFieldNamePanel::EFieldType field_type = CFieldNamePanel::GetFieldTypeFromName(field.substr(0, pos));
        if (field_type != CFieldNamePanel::eFieldType_Unknown) {
            string field_name_str = CFieldNamePanel::GetFieldTypeName(field_type);
            string tmp = field;
            if (NStr::StartsWith(tmp, field_name_str)) {
                tmp = tmp.substr(field_name_str.length());
            } else {
                tmp = tmp.substr(pos);
            }
            NStr::TruncateSpacesInPlace(tmp);
            SetFieldType(field_type, m_IsPair);
            if (m_Field1 != NULL) {
                rval = m_Field1->SetFieldName(tmp);
            }
            x_UpdateParent();
        }
    }
    return rval;
}


string CFieldChoicePanel::AutoMatch(string field_name)
{
    string answer = "";
    // the first part may tell us what kind of field this is.
    CFieldNamePanel::EFieldType field_type = GetFieldTypeFromName(field_name);
    /* if (field_type != CFieldNamePanel::eFieldType_Unknown && field_type != CFieldNamePanel::eFieldType_SeqId) {
        string prefix = CFieldNamePanel::GetFieldTypeName(field_type);
        field_name = field_name.substr(0, prefix.length()); // what is this? why is it here? This seems to limit the input string to the length of field type name, such as "source qualifier" or "feature qualifier". Makes no sense.
        NStr::TruncateSpacesInPlace(field_name);
        } */
    answer = AutoMatch(field_name, field_type);
    return answer;
}


bool CFieldChoicePanel::LooksLikeHeader(const vector<string>& field_names)
{
    if (field_names.empty()) {
        return false;
    }

    unsigned int unmatched = 0;
    ITERATE(vector<string>, it, field_names) {
        string guess = AutoMatch(*it);
        if (NStr::IsBlank(guess)) {
            ++unmatched;
        }
    }

    return (unmatched <= (2*field_names.size())/3);
}


string CFieldChoicePanel::AutoMatch(string field_name, CFieldNamePanel::EFieldType field_type)
{
    string answer = "";

    switch (field_type) {
        case CFieldNamePanel::eFieldType_Unknown:
            {
                vector<CFieldNamePanel::EFieldType> guess_preference;
                guess_preference.push_back(CFieldNamePanel::eFieldType_Source);
                guess_preference.push_back(CFieldNamePanel::eFieldType_CDSGeneProt);
                guess_preference.push_back(CFieldNamePanel::eFieldType_RNA);
                guess_preference.push_back(CFieldNamePanel::eFieldType_Feature);
                guess_preference.push_back(CFieldNamePanel::eFieldType_Misc);
                ITERATE(vector<CFieldNamePanel::EFieldType>, it, guess_preference) {
                    answer = AutoMatch(field_name, *it);
                    if (!NStr::IsBlank(answer)) {
                        break;
                    }
                }
            }
            break;
        case CFieldNamePanel::eFieldType_Source:
            answer = AutoMatchSrc(field_name);
            break;
        case CFieldNamePanel::eFieldType_Taxname:
            answer = AutoMatchSrc(field_name);
            break;
        case CFieldNamePanel::eFieldType_Feature:
            answer = AutoMatchFeat(field_name);
            break;
        case CFieldNamePanel::eFieldType_CDSGeneProt:
            answer = AutoMatchCGP(field_name);
            break;
        case CFieldNamePanel::eFieldType_RNA:
            answer = AutoMatchRNA(field_name);
            break;
        case CFieldNamePanel::eFieldType_MolInfo:
            break;
        case CFieldNamePanel::eFieldType_Pub:
            answer = AutoMatchPub(field_name);
            break;
        case CFieldNamePanel::eFieldType_StructuredComment:
            break;
        case CFieldNamePanel::eFieldType_DBLink:
            answer = AutoMatchDBLink(field_name);
            break;
        case CFieldNamePanel::eFieldType_Misc:
            answer = AutoMatchMisc(field_name);
            break;
        case CFieldNamePanel::eFieldType_SeqId:
            answer = "SeqId";
            break;
        default:
            break;

    }
    if (!NStr::IsBlank(answer) && field_type != CFieldNamePanel::eFieldType_Unknown) {
        answer = GetFieldTypeName(field_type) + " " + answer;
    }
    return answer;
}

static const string kInst_suffix("-inst");
static const string kColl_suffix("-coll");
static const string kSpecid_suffix("-specid");

string CFieldChoicePanel::AutoMatchSrc(string field_name)
{
    string answer = "";
    if (NStr::EqualNocase(field_name, "genome")) {
        answer = "genome";
    } else if (NStr::EqualNocase(field_name, "origin")) {
        answer = "origin";
    } else if (IsOrgColumnName(field_name)) {
        answer = "taxname";
    } else if (IsSubSourceNoteName(field_name)) {
        answer = kSubSourceNote;
    } else if (IsOrgModNoteName(field_name)) {
        answer = kOrgModNote;
    } else if (NStr::EqualNocase(field_name, "voucher")) {
        answer = "specimen-voucher";
    } else if (NStr::EqualNocase(field_name, kDbXref)) {
        answer = kDbXref;
    } else if (NStr::EndsWith(field_name, kInst_suffix)
             || NStr::EndsWith(field_name, kColl_suffix)
             || NStr::EndsWith(field_name, kSpecid_suffix)) {
        return field_name;
    }
    else if (NStr::EqualNocase(field_name, kFwdPrimerName) || NStr::EqualNocase(field_name, kFwdPrimerSeq)
             || NStr::EqualNocase(field_name, kRevPrimerName) || NStr::EqualNocase(field_name, kRevPrimerSeq)) {
        return field_name;
    }
    else {
        // see if it's a SubSource subtype:
        try {
            CSubSource::TSubtype st = CSubSource::GetSubtypeValue(NStr::ToLower(field_name), CSubSource::eVocabulary_insdc);
            answer = CSubSource::GetSubtypeName(st);
        } catch (const exception&) {
            // OrgMod?
            try {
                COrgMod::TSubtype st = COrgMod::GetSubtypeValue(NStr::ToLower(field_name), COrgMod::eVocabulary_insdc);
                answer = COrgMod::GetSubtypeName(st);
            } catch (const exception&) {
                // neither
            }
        }
    }

    return answer;
}


string CFieldChoicePanel::AutoMatchCGP(string field_name)
{
    string answer = "";
    vector<string> options = CCDSGeneProtFieldNamePanel::GetStrings();
    ITERATE(vector<string>, it, options) {
        if (QualifierNamesAreEquivalent(field_name, *it)) {
            answer = *it;
            break;
        }
    }
    return answer;
}


string CFieldChoicePanel::AutoMatchMisc(string field_name)
{
    string answer = "";
    vector<string> options = CMiscFieldPanel::GetStrings();
    ITERATE(vector<string>, it, options) {
        if (QualifierNamesAreEquivalent(field_name, *it)) {
            answer = *it;
            break;
        }
    }
    return answer;
}


string CFieldChoicePanel::AutoMatchFeat(string field_name)
{
    string answer = "";

    size_t pos = NStr::Find(field_name, " ", NStr::eCase, NStr::eReverseSearch);
    if (pos != string::npos) {
        string feat = field_name.substr(0, pos);
        string qual = field_name.substr(pos + 1);
        const CFeatList* feat_list = CSeqFeatData::GetFeatList();
        vector<string> features;
        feat_list->GetDescriptions(features, false);
        string answer_feat = "";
        ITERATE(vector<string>, it, features) {
            if (QualifierNamesAreEquivalent(*it, feat)) {
                answer_feat = *it;
                break;
            }
        }
        if (!NStr::IsBlank(answer_feat)) {
            string answer_qual = "";
            int qual_num = CSeqFeatData::eQual_allele;
            while (qual_num <= CSeqFeatData::eQual_whole_replicon) {
                string check_qual = CSeqFeatData::GetQualifierAsString((CSeqFeatData::EQualifier)qual_num);
                if (QualifierNamesAreEquivalent(qual, check_qual)) {
                    answer_qual = check_qual;
                    break;
                }
                qual_num++;
            }
           
            if (NStr::EqualNocase(qual, "locus") 
                || NStr::EqualNocase(qual, "satellite_type") || (NStr::EqualNocase(qual, "satellite_name")) 
                || (NStr::EqualNocase(qual, "mobile_element_type"))  || (NStr::EqualNocase(qual, "mobile_element_name")) 
                || (NStr::EqualNocase(qual, "mobile_element_type_type"))  || (NStr::EqualNocase(qual, "mobile_element_type_name")) )
            {
                answer_qual = qual;
            }
            if (!NStr::IsBlank(answer_qual)) {
                answer = answer_feat + " " + answer_qual;
            }
        }
    }
    return answer;
}


string CFieldChoicePanel::AutoMatchRNA(string field_name)
{
    string answer = "";
    vector<string> rna_types = CRNAFieldNamePanel::GetRNATypes();
    string answer_rna_type = "";
    string remainder = field_name;
    size_t pos = NStr::Find(field_name, " ");
    if (pos != string::npos) {
        string check_rna_type = field_name.substr(0, pos);
        ITERATE(vector<string>, it, rna_types) {
            if (QualifierNamesAreEquivalent(check_rna_type, *it)) {
                answer_rna_type = *it;
                remainder = field_name.substr(pos);
            }
            break;
        }
    }
    if (NStr::IsBlank(answer_rna_type)) {
        answer_rna_type = rna_types[0];
    }

    vector<string> rna_fields = CRNAFieldNamePanel::GetRNAFields();
    string ncrna_class = "";
    string answer_field = "";
    if (NStr::Equal(answer_rna_type, "ncRNA")) {
        ITERATE(vector<string>, it, rna_fields) {
            if (NStr::EndsWith(remainder, *it, NStr::eNocase)) {
                if (remainder.length() > (*it).length()) {
                    ncrna_class = remainder.substr(0, remainder.length() - (*it).length());
                }
                answer_field = *it;
                break;
            }
        }
    } else {
        ITERATE(vector<string>, it, rna_fields) {
            if (QualifierNamesAreEquivalent(remainder, *it)) {
                answer_field = *it;
                break;
            }
        }
    }
    if (!NStr::IsBlank(answer_field)) {
        answer = answer_rna_type;
        if (!NStr::IsBlank(ncrna_class)) {
            answer += " " + ncrna_class;
        }
        answer += " " + answer_field;
    }

    return answer;
}


string CFieldChoicePanel::AutoMatchPub(string field_name)
{
    string answer;
    field_name = CPubField::NormalizePubFieldName(field_name);
    vector<string> field_names = CPubField::GetFieldNames();
    ITERATE(vector<string>, it, field_names) {
        if (QualifierNamesAreEquivalent(field_name, *it)) {
            answer = *it;
            break;
        }
    }

    return answer;
}


string CFieldChoicePanel::AutoMatchDBLink(string field_name)
{
    string answer = "";
    vector<string> field_names = CDBLinkField::GetFieldNames();
    ITERATE(vector<string>, it, field_names) {
        if (QualifierNamesAreEquivalent(field_name, *it)) {
            answer = *it;
            break;
        }
    }

    return answer;
}

string CFieldChoicePanel::AutoMatchMolInfo(string field_name)
{
    string answer;
    vector<string> field_names = CMolInfoField::GetFieldNames();
    ITERATE(vector<string>, it, field_names) {
        if (QualifierNamesAreEquivalent(field_name, *it)) {
            answer = *it;
            break;
        }
    }

    return answer;
}

END_NCBI_SCOPE
